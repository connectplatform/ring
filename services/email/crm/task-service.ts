/**
 * Email Task Service
 * ==================
 * Manages follow-up tasks and escalations for email threads
 * Reference: Email Automation Specialist skillset
 */

import { logger } from '@/lib/logger';

export interface EmailTask {
  id: string;
  threadId: string;
  messageId: string | null;
  title: string;
  description: string | null;
  taskType: TaskType;
  dueDate: Date | null;
  assignedTo: string | null;
  status: TaskStatus;
  priority: TaskPriority;
  autoGenerated: boolean;
  triggerReason: string | null;
  completedAt: Date | null;
  completedBy: string | null;
  completionNotes: string | null;
  createdAt: Date;
  updatedAt: Date;
}

export type TaskType = 'follow_up' | 'escalation' | 'action_required' | 'review';
export type TaskStatus = 'open' | 'in_progress' | 'completed' | 'cancelled' | 'overdue';
export type TaskPriority = 'low' | 'normal' | 'high' | 'urgent';

export interface TaskCreateInput {
  threadId: string;
  messageId?: string;
  title: string;
  description?: string;
  taskType: TaskType;
  dueDate?: Date;
  dueDays?: number; // Alternative: set due date N days from now
  assignedTo?: string;
  priority?: TaskPriority;
  autoGenerated?: boolean;
  triggerReason?: string;
}

export interface TaskUpdateInput {
  title?: string;
  description?: string;
  dueDate?: Date;
  assignedTo?: string;
  status?: TaskStatus;
  priority?: TaskPriority;
}

export interface TaskCompleteInput {
  completedBy: string;
  completionNotes?: string;
}

export interface TaskSearchParams {
  threadId?: string;
  assignedTo?: string;
  status?: TaskStatus | TaskStatus[];
  taskType?: TaskType;
  priority?: TaskPriority | TaskPriority[];
  dueBefore?: Date;
  dueAfter?: Date;
  limit?: number;
  offset?: number;
}

// Auto-creation rules
export interface TaskAutoCreationRule {
  id: string;
  name: string;
  conditions: {
    intent?: string[];
    sentiment?: string[];
    priority?: string[];
    isFirstContact?: boolean;
    hasAttachments?: boolean;
  };
  action: {
    taskType: TaskType;
    titleTemplate: string;
    descriptionTemplate?: string;
    priority: TaskPriority;
    dueDays: number;
    assignedTo?: string;
  };
  enabled: boolean;
}

// Default auto-creation rules
const DEFAULT_RULES: TaskAutoCreationRule[] = [
  {
    id: 'rule_enterprise_inquiry',
    name: 'Enterprise Inquiry Follow-up',
    conditions: {
      intent: ['enterprise_inquiry'],
    },
    action: {
      taskType: 'follow_up',
      titleTemplate: 'Follow up with enterprise lead: {senderName}',
      descriptionTemplate: 'Enterprise inquiry about: {subject}',
      priority: 'urgent',
      dueDays: 1,
    },
    enabled: true,
  },
  {
    id: 'rule_demo_request',
    name: 'Demo Request Scheduling',
    conditions: {
      intent: ['demo_request'],
    },
    action: {
      taskType: 'action_required',
      titleTemplate: 'Schedule demo for: {senderName}',
      descriptionTemplate: 'Demo requested - respond within 24 hours',
      priority: 'high',
      dueDays: 1,
    },
    enabled: true,
  },
  {
    id: 'rule_complaint',
    name: 'Complaint Escalation',
    conditions: {
      intent: ['complaint'],
    },
    action: {
      taskType: 'escalation',
      titleTemplate: 'Customer complaint: {subject}',
      descriptionTemplate: 'Customer complaint requires immediate attention from {senderEmail}',
      priority: 'urgent',
      dueDays: 0, // Same day
    },
    enabled: true,
  },
  {
    id: 'rule_bug_report',
    name: 'Bug Report Triage',
    conditions: {
      intent: ['bug_report'],
    },
    action: {
      taskType: 'review',
      titleTemplate: 'Triage bug report: {subject}',
      descriptionTemplate: 'Bug reported by {senderEmail} - needs technical review',
      priority: 'high',
      dueDays: 2,
    },
    enabled: true,
  },
  {
    id: 'rule_at_risk',
    name: 'At-Risk Customer',
    conditions: {
      sentiment: ['frustrated', 'negative'],
    },
    action: {
      taskType: 'escalation',
      titleTemplate: 'At-risk customer: {senderName}',
      descriptionTemplate: 'Customer showing frustration - proactive outreach recommended',
      priority: 'high',
      dueDays: 1,
    },
    enabled: true,
  },
  {
    id: 'rule_partnership',
    name: 'Partnership Inquiry',
    conditions: {
      intent: ['partnership'],
    },
    action: {
      taskType: 'follow_up',
      titleTemplate: 'Partnership inquiry from: {senderCompany}',
      descriptionTemplate: 'Partnership proposal - requires business review',
      priority: 'high',
      dueDays: 2,
    },
    enabled: true,
  },
];

// Database interface
export interface TaskRepository {
  findById(id: string): Promise<EmailTask | null>;
  findByThreadId(threadId: string): Promise<EmailTask[]>;
  create(input: TaskCreateInput): Promise<EmailTask>;
  update(id: string, input: TaskUpdateInput): Promise<EmailTask>;
  complete(id: string, input: TaskCompleteInput): Promise<EmailTask>;
  search(params: TaskSearchParams): Promise<EmailTask[]>;
  markOverdue(): Promise<number>;
  delete(id: string): Promise<void>;
}

export class EmailTaskService {
  private rules: TaskAutoCreationRule[] = DEFAULT_RULES;
  
  constructor(private repository: TaskRepository) {}
  
  /**
   * Create a task manually
   */
  async createTask(input: TaskCreateInput): Promise<EmailTask> {
    // Calculate due date if dueDays provided
    let dueDate = input.dueDate;
    if (!dueDate && input.dueDays !== undefined) {
      dueDate = new Date();
      dueDate.setDate(dueDate.getDate() + input.dueDays);
    }
    
    const task = await this.repository.create({
      ...input,
      dueDate,
      priority: input.priority || 'normal',
      autoGenerated: input.autoGenerated || false,
    });
    
    logger.info('[EmailTaskService] Task created', {
      taskId: task.id,
      threadId: task.threadId,
      taskType: task.taskType,
      priority: task.priority,
      dueDate: task.dueDate?.toISOString(),
    });
    
    return task;
  }
  
  /**
   * Auto-create tasks based on email analysis
   */
  async autoCreateTasks(params: {
    threadId: string;
    messageId: string;
    senderEmail: string;
    senderName: string | null;
    senderCompany: string | null;
    subject: string;
    intent: string;
    sentiment: string;
    priority: string;
    isFirstContact: boolean;
    hasAttachments: boolean;
  }): Promise<EmailTask[]> {
    const createdTasks: EmailTask[] = [];
    
    for (const rule of this.rules) {
      if (!rule.enabled) continue;
      
      // Check conditions
      if (!this.matchesConditions(rule.conditions, params)) continue;
      
      // Apply template variables
      const variables = {
        senderEmail: params.senderEmail,
        senderName: params.senderName || 'Unknown',
        senderCompany: params.senderCompany || 'Unknown Company',
        subject: params.subject,
        intent: params.intent,
        sentiment: params.sentiment,
      };
      
      const title = this.applyTemplate(rule.action.titleTemplate, variables);
      const description = rule.action.descriptionTemplate 
        ? this.applyTemplate(rule.action.descriptionTemplate, variables)
        : null;
      
      // Create task
      const task = await this.createTask({
        threadId: params.threadId,
        messageId: params.messageId,
        title,
        description: description || undefined,
        taskType: rule.action.taskType,
        dueDays: rule.action.dueDays,
        assignedTo: rule.action.assignedTo,
        priority: rule.action.priority,
        autoGenerated: true,
        triggerReason: `Auto-created by rule: ${rule.name}`,
      });
      
      createdTasks.push(task);
      
      logger.info('[EmailTaskService] Auto-created task', {
        taskId: task.id,
        ruleName: rule.name,
        ruleId: rule.id,
      });
    }
    
    return createdTasks;
  }
  
  /**
   * Check if email matches rule conditions
   */
  private matchesConditions(
    conditions: TaskAutoCreationRule['conditions'],
    params: {
      intent: string;
      sentiment: string;
      priority: string;
      isFirstContact: boolean;
      hasAttachments: boolean;
    }
  ): boolean {
    if (conditions.intent && !conditions.intent.includes(params.intent)) {
      return false;
    }
    if (conditions.sentiment && !conditions.sentiment.includes(params.sentiment)) {
      return false;
    }
    if (conditions.priority && !conditions.priority.includes(params.priority)) {
      return false;
    }
    if (conditions.isFirstContact !== undefined && conditions.isFirstContact !== params.isFirstContact) {
      return false;
    }
    if (conditions.hasAttachments !== undefined && conditions.hasAttachments !== params.hasAttachments) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Apply template variables
   */
  private applyTemplate(template: string, variables: Record<string, string>): string {
    let result = template;
    for (const [key, value] of Object.entries(variables)) {
      result = result.replace(new RegExp(`\\{${key}\\}`, 'g'), value);
    }
    return result;
  }
  
  /**
   * Update task
   */
  async updateTask(id: string, input: TaskUpdateInput): Promise<EmailTask> {
    const task = await this.repository.update(id, input);
    
    logger.info('[EmailTaskService] Task updated', {
      taskId: id,
      updates: Object.keys(input),
    });
    
    return task;
  }
  
  /**
   * Complete a task
   */
  async completeTask(id: string, input: TaskCompleteInput): Promise<EmailTask> {
    const task = await this.repository.complete(id, input);
    
    logger.info('[EmailTaskService] Task completed', {
      taskId: id,
      completedBy: input.completedBy,
    });
    
    return task;
  }
  
  /**
   * Cancel a task
   */
  async cancelTask(id: string): Promise<EmailTask> {
    return this.repository.update(id, { status: 'cancelled' });
  }
  
  /**
   * Get tasks for a thread
   */
  async getThreadTasks(threadId: string): Promise<EmailTask[]> {
    return this.repository.findByThreadId(threadId);
  }
  
  /**
   * Get tasks assigned to user
   */
  async getUserTasks(userId: string, includeCompleted = false): Promise<EmailTask[]> {
    const statuses: TaskStatus[] = includeCompleted 
      ? ['open', 'in_progress', 'completed', 'overdue']
      : ['open', 'in_progress', 'overdue'];
    
    return this.repository.search({
      assignedTo: userId,
      status: statuses,
    });
  }
  
  /**
   * Get overdue tasks
   */
  async getOverdueTasks(): Promise<EmailTask[]> {
    return this.repository.search({
      status: 'overdue',
    });
  }
  
  /**
   * Get urgent tasks
   */
  async getUrgentTasks(): Promise<EmailTask[]> {
    return this.repository.search({
      status: ['open', 'in_progress'],
      priority: ['urgent', 'high'],
    });
  }
  
  /**
   * Mark overdue tasks (run periodically)
   */
  async processOverdueTasks(): Promise<number> {
    const count = await this.repository.markOverdue();
    
    if (count > 0) {
      logger.warn('[EmailTaskService] Tasks marked as overdue', { count });
    }
    
    return count;
  }
  
  /**
   * Get task statistics
   */
  async getStatistics(): Promise<{
    total: number;
    byStatus: Record<TaskStatus, number>;
    byPriority: Record<TaskPriority, number>;
    byType: Record<TaskType, number>;
    avgCompletionTimeHours: number;
  }> {
    const tasks = await this.repository.search({ limit: 10000 });
    
    const byStatus: Record<TaskStatus, number> = {
      open: 0,
      in_progress: 0,
      completed: 0,
      cancelled: 0,
      overdue: 0,
    };
    
    const byPriority: Record<TaskPriority, number> = {
      low: 0,
      normal: 0,
      high: 0,
      urgent: 0,
    };
    
    const byType: Record<TaskType, number> = {
      follow_up: 0,
      escalation: 0,
      action_required: 0,
      review: 0,
    };
    
    let totalCompletionTime = 0;
    let completedCount = 0;
    
    for (const task of tasks) {
      byStatus[task.status]++;
      byPriority[task.priority]++;
      byType[task.taskType]++;
      
      if (task.status === 'completed' && task.completedAt) {
        const completionTime = new Date(task.completedAt).getTime() - new Date(task.createdAt).getTime();
        totalCompletionTime += completionTime;
        completedCount++;
      }
    }
    
    const avgCompletionTimeHours = completedCount > 0 
      ? Math.round(totalCompletionTime / completedCount / (1000 * 60 * 60))
      : 0;
    
    return {
      total: tasks.length,
      byStatus,
      byPriority,
      byType,
      avgCompletionTimeHours,
    };
  }
  
  /**
   * Add or update custom rule
   */
  addRule(rule: TaskAutoCreationRule): void {
    const existingIndex = this.rules.findIndex(r => r.id === rule.id);
    if (existingIndex >= 0) {
      this.rules[existingIndex] = rule;
    } else {
      this.rules.push(rule);
    }
  }
  
  /**
   * Remove rule
   */
  removeRule(ruleId: string): void {
    this.rules = this.rules.filter(r => r.id !== ruleId);
  }
  
  /**
   * Get all rules
   */
  getRules(): TaskAutoCreationRule[] {
    return [...this.rules];
  }
}

// In-memory repository
export class InMemoryTaskRepository implements TaskRepository {
  private tasks: Map<string, EmailTask> = new Map();
  private counter = 0;
  
  async findById(id: string): Promise<EmailTask | null> {
    return this.tasks.get(id) || null;
  }
  
  async findByThreadId(threadId: string): Promise<EmailTask[]> {
    return Array.from(this.tasks.values()).filter(t => t.threadId === threadId);
  }
  
  async create(input: TaskCreateInput): Promise<EmailTask> {
    const id = `task_${++this.counter}`;
    const now = new Date();
    
    const task: EmailTask = {
      id,
      threadId: input.threadId,
      messageId: input.messageId || null,
      title: input.title,
      description: input.description || null,
      taskType: input.taskType,
      dueDate: input.dueDate || null,
      assignedTo: input.assignedTo || null,
      status: 'open',
      priority: input.priority || 'normal',
      autoGenerated: input.autoGenerated || false,
      triggerReason: input.triggerReason || null,
      completedAt: null,
      completedBy: null,
      completionNotes: null,
      createdAt: now,
      updatedAt: now,
    };
    
    this.tasks.set(id, task);
    return task;
  }
  
  async update(id: string, input: TaskUpdateInput): Promise<EmailTask> {
    const task = this.tasks.get(id);
    if (!task) throw new Error('Task not found');
    
    const updated: EmailTask = {
      ...task,
      ...input,
      updatedAt: new Date(),
    };
    
    this.tasks.set(id, updated);
    return updated;
  }
  
  async complete(id: string, input: TaskCompleteInput): Promise<EmailTask> {
    const task = this.tasks.get(id);
    if (!task) throw new Error('Task not found');
    
    const now = new Date();
    const completed: EmailTask = {
      ...task,
      status: 'completed',
      completedAt: now,
      completedBy: input.completedBy,
      completionNotes: input.completionNotes || null,
      updatedAt: now,
    };
    
    this.tasks.set(id, completed);
    return completed;
  }
  
  async search(params: TaskSearchParams): Promise<EmailTask[]> {
    let results = Array.from(this.tasks.values());
    
    if (params.threadId) {
      results = results.filter(t => t.threadId === params.threadId);
    }
    if (params.assignedTo) {
      results = results.filter(t => t.assignedTo === params.assignedTo);
    }
    if (params.status) {
      const statuses = Array.isArray(params.status) ? params.status : [params.status];
      results = results.filter(t => statuses.includes(t.status));
    }
    if (params.taskType) {
      results = results.filter(t => t.taskType === params.taskType);
    }
    if (params.priority) {
      const priorities = Array.isArray(params.priority) ? params.priority : [params.priority];
      results = results.filter(t => priorities.includes(t.priority));
    }
    if (params.dueBefore) {
      results = results.filter(t => t.dueDate && t.dueDate <= params.dueBefore!);
    }
    if (params.dueAfter) {
      results = results.filter(t => t.dueDate && t.dueDate >= params.dueAfter!);
    }
    
    const offset = params.offset || 0;
    const limit = params.limit || 100;
    
    return results.slice(offset, offset + limit);
  }
  
  async markOverdue(): Promise<number> {
    const now = new Date();
    let count = 0;
    
    for (const task of this.tasks.values()) {
      if (
        task.dueDate && 
        task.dueDate < now && 
        ['open', 'in_progress'].includes(task.status)
      ) {
        task.status = 'overdue';
        task.updatedAt = now;
        count++;
      }
    }
    
    return count;
  }
  
  async delete(id: string): Promise<void> {
    this.tasks.delete(id);
  }
}

// Singleton
let serviceInstance: EmailTaskService | null = null;

export function getEmailTaskService(): EmailTaskService {
  if (!serviceInstance) {
    serviceInstance = new EmailTaskService(new InMemoryTaskRepository());
  }
  return serviceInstance;
}

export default EmailTaskService;
