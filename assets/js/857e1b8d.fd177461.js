"use strict";(self.webpackChunkring_docs=self.webpackChunkring_docs||[]).push([[6919],{24202:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"api/notifications/read-all","title":"Mark All Notifications as Read API","description":"Overview","source":"@site/docs/uk/api/notifications/read-all.md","sourceDirName":"api/notifications","slug":"/api/notifications/read-all","permalink":"/ring/uk/api/notifications/read-all","draft":false,"unlisted":false,"editUrl":"https://github.com/connectplatform/ring/ring-docs/tree/main/docs/uk/api/notifications/read-all.md","tags":[],"version":"current","lastUpdatedAt":1750331037000,"frontMatter":{},"sidebar":"apiSidebar","previous":{"title":"Mark Notification as Read API","permalink":"/ring/uk/api/notifications/read"},"next":{"title":"Notification Preferences API","permalink":"/ring/uk/api/notifications/preferences"}}');var i=t(74848),a=t(28453);const r={},o="Mark All Notifications as Read API",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Endpoint Details",id:"endpoint-details",level:2},{value:"Authentication",id:"authentication",level:2},{value:"Request Body",id:"request-body",level:2},{value:"Response Format",id:"response-format",level:2},{value:"Success Response (200)",id:"success-response-200",level:3},{value:"Error Responses",id:"error-responses",level:3},{value:"Unauthorized (401)",id:"unauthorized-401",level:4},{value:"Internal Server Error (500)",id:"internal-server-error-500",level:4},{value:"Implementation Examples",id:"implementation-examples",level:2},{value:"React Component with Bulk Action",id:"react-component-with-bulk-action",level:3},{value:"Custom Hook for Bulk Operations",id:"custom-hook-for-bulk-operations",level:3},{value:"Server Action (Next.js 13+)",id:"server-action-nextjs-13",level:3},{value:"React Hook Form Integration",id:"react-hook-form-integration",level:3},{value:"cURL Example",id:"curl-example",level:3},{value:"Business Logic",id:"business-logic",level:2},{value:"Database Operations",id:"database-operations",level:2},{value:"Query Pattern",id:"query-pattern",level:3},{value:"Database Schema Impact",id:"database-schema-impact",level:3},{value:"Before Update",id:"before-update",level:4},{value:"After Bulk Update",id:"after-bulk-update",level:4},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Performance Notes",id:"performance-notes",level:2},{value:"Rate Limiting",id:"rate-limiting",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Real-time Updates Integration",id:"real-time-updates-integration",level:2},{value:"Testing",id:"testing",level:2},{value:"Unit Test Example",id:"unit-test-example",level:3},{value:"Integration Test",id:"integration-test",level:3},{value:"Related Endpoints",id:"related-endpoints",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"mark-all-notifications-as-read-api",children:"Mark All Notifications as Read API"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"Mark All Notifications as Read API"})," allows authenticated users to mark all their notifications as read in a single request. This endpoint is useful for bulk operations and improving user experience in notification management interfaces."]}),"\n",(0,i.jsx)(n.h2,{id:"endpoint-details",children:"Endpoint Details"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"URL"}),": ",(0,i.jsx)(n.code,{children:"/api/notifications/read-all"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Method"}),": ",(0,i.jsx)(n.code,{children:"POST"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Authentication"}),": Required (NextAuth.js session)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Content-Type"}),": ",(0,i.jsx)(n.code,{children:"application/json"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"authentication",children:"Authentication"}),"\n",(0,i.jsx)(n.p,{children:"This endpoint requires user authentication via NextAuth.js session:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"import { getSession } from 'next-auth/react'\n\nconst session = await getSession()\nif (!session) {\n  // Handle unauthenticated state\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"request-body",children:"Request Body"}),"\n",(0,i.jsx)(n.p,{children:"This endpoint does not require a request body. All notifications for the authenticated user will be marked as read."}),"\n",(0,i.jsx)(n.h2,{id:"response-format",children:"Response Format"}),"\n",(0,i.jsx)(n.h3,{id:"success-response-200",children:"Success Response (200)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "success": true,\n  "message": "5 notifications marked as read",\n  "markedCount": 5\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"error-responses",children:"Error Responses"}),"\n",(0,i.jsx)(n.h4,{id:"unauthorized-401",children:"Unauthorized (401)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "error": "User not authenticated"\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"internal-server-error-500",children:"Internal Server Error (500)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "error": "Failed to mark all notifications as read. Please try again later."\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"implementation-examples",children:"Implementation Examples"}),"\n",(0,i.jsx)(n.h3,{id:"react-component-with-bulk-action",children:"React Component with Bulk Action"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { useState } from 'react'\nimport { useSession } from 'next-auth/react'\n\ninterface Notification {\n  id: string\n  title: string\n  message: string\n  isRead: boolean\n  createdAt: string\n  type: 'info' | 'warning' | 'success' | 'error'\n}\n\nfunction NotificationHeader({ \n  notifications, \n  onMarkAllAsRead \n}: { \n  notifications: Notification[]\n  onMarkAllAsRead: () => void \n}) {\n  const { data: session } = useSession()\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n\n  const unreadCount = notifications.filter(n => !n.isRead).length\n\n  const handleMarkAllAsRead = async () => {\n    if (!session || unreadCount === 0) return\n\n    setLoading(true)\n    setError(null)\n\n    try {\n      const response = await fetch('/api/notifications/read-all', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.error || 'Failed to mark all as read')\n      }\n\n      const result = await response.json()\n      console.log(`Marked ${result.markedCount} notifications as read`)\n      \n      onMarkAllAsRead()\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Unknown error occurred')\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  return (\n    <div className=\"flex items-center justify-between p-4 border-b\">\n      <div>\n        <h2 className=\"text-xl font-semibold\">Notifications</h2>\n        <p className=\"text-sm text-gray-500\">\n          {unreadCount > 0 ? `${unreadCount} unread` : 'All caught up!'}\n        </p>\n      </div>\n\n      {error && (\n        <div className=\"bg-red-100 border border-red-400 text-red-700 px-3 py-1 rounded text-sm\">\n          {error}\n        </div>\n      )}\n\n      {unreadCount > 0 && (\n        <button\n          onClick={handleMarkAllAsRead}\n          disabled={loading}\n          className=\"px-4 py-2 text-sm bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50\"\n        >\n          {loading ? 'Marking...' : `Mark All as Read (${unreadCount})`}\n        </button>\n      )}\n    </div>\n  )\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"custom-hook-for-bulk-operations",children:"Custom Hook for Bulk Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { useState, useCallback } from 'react'\nimport { useSession } from 'next-auth/react'\n\nexport function useNotificationBulkActions() {\n  const { data: session } = useSession()\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n\n  const markAllAsRead = useCallback(async () => {\n    if (!session) return { success: false, error: 'Not authenticated' }\n\n    setLoading(true)\n    setError(null)\n\n    try {\n      const response = await fetch('/api/notifications/read-all', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      })\n\n      if (!response.ok) {\n        const errorData = await response.json()\n        throw new Error(errorData.error || 'Failed to mark all notifications as read')\n      }\n\n      const result = await response.json()\n      \n      return {\n        success: true,\n        markedCount: result.markedCount,\n        message: result.message\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred'\n      setError(errorMessage)\n      return { success: false, error: errorMessage }\n    } finally {\n      setLoading(false)\n    }\n  }, [session])\n\n  const markSelectedAsRead = useCallback(async (notificationIds: string[]) => {\n    if (!session || notificationIds.length === 0) return { success: false, error: 'Invalid request' }\n\n    setLoading(true)\n    setError(null)\n\n    try {\n      const results = await Promise.all(\n        notificationIds.map(id => \n          fetch(`/api/notifications/${id}/read`, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n            },\n          })\n        )\n      )\n\n      const failed = results.filter(r => !r.ok)\n      if (failed.length > 0) {\n        throw new Error(`Failed to mark ${failed.length} notifications as read`)\n      }\n\n      return {\n        success: true,\n        markedCount: results.length,\n        message: `${results.length} notifications marked as read`\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred'\n      setError(errorMessage)\n      return { success: false, error: errorMessage }\n    } finally {\n      setLoading(false)\n    }\n  }, [session])\n\n  return {\n    markAllAsRead,\n    markSelectedAsRead,\n    loading,\n    error,\n    clearError: () => setError(null)\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"server-action-nextjs-13",children:"Server Action (Next.js 13+)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"'use server'\n\nimport { auth } from '@/auth'\nimport { redirect } from 'next/navigation'\nimport { revalidatePath } from 'next/cache'\n\nexport async function markAllNotificationsAsReadAction() {\n  const session = await auth()\n  \n  if (!session) {\n    redirect('/auth/signin')\n  }\n\n  try {\n    const response = await fetch(`${process.env.NEXTAUTH_URL}/api/notifications/read-all`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Cookie': request.headers.get('cookie') || '',\n      },\n    })\n\n    if (!response.ok) {\n      const error = await response.json()\n      throw new Error(error.error || 'Failed to mark all notifications as read')\n    }\n\n    const result = await response.json()\n    \n    // Revalidate the notifications page\n    revalidatePath('/notifications')\n    \n    return {\n      success: true,\n      markedCount: result.markedCount,\n      message: result.message\n    }\n    \n  } catch (error) {\n    console.error('Server action error:', error)\n    throw error\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"react-hook-form-integration",children:"React Hook Form Integration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'import { useForm } from \'react-hook-form\'\nimport { useNotificationBulkActions } from \'@/hooks/useNotificationBulkActions\'\n\ninterface NotificationBulkForm {\n  selectAll: boolean\n  selectedIds: string[]\n}\n\nfunction NotificationBulkActions({ notifications }: { notifications: Notification[] }) {\n  const { register, watch, setValue, handleSubmit } = useForm<NotificationBulkForm>({\n    defaultValues: {\n      selectAll: false,\n      selectedIds: []\n    }\n  })\n\n  const { markAllAsRead, markSelectedAsRead, loading } = useNotificationBulkActions()\n  \n  const watchSelectAll = watch(\'selectAll\')\n  const watchSelectedIds = watch(\'selectedIds\')\n\n  const handleSelectAll = (checked: boolean) => {\n    setValue(\'selectAll\', checked)\n    if (checked) {\n      const unreadIds = notifications.filter(n => !n.isRead).map(n => n.id)\n      setValue(\'selectedIds\', unreadIds)\n    } else {\n      setValue(\'selectedIds\', [])\n    }\n  }\n\n  const onSubmit = async (data: NotificationBulkForm) => {\n    if (data.selectAll || data.selectedIds.length === notifications.filter(n => !n.isRead).length) {\n      // Mark all as read if all unread notifications are selected\n      await markAllAsRead()\n    } else {\n      // Mark selected as read\n      await markSelectedAsRead(data.selectedIds)\n    }\n  }\n\n  const unreadCount = notifications.filter(n => !n.isRead).length\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">\n      <div className="flex items-center justify-between p-4 bg-gray-50 rounded-lg">\n        <label className="flex items-center space-x-2">\n          <input\n            type="checkbox"\n            checked={watchSelectAll}\n            onChange={(e) => handleSelectAll(e.target.checked)}\n            className="w-4 h-4 text-blue-600"\n          />\n          <span className="text-sm font-medium">\n            Select All Unread ({unreadCount})\n          </span>\n        </label>\n\n        <button\n          type="submit"\n          disabled={loading || watchSelectedIds.length === 0}\n          className="px-4 py-2 text-sm bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"\n        >\n          {loading \n            ? \'Processing...\' \n            : watchSelectedIds.length === unreadCount \n              ? \'Mark All as Read\'\n              : `Mark Selected as Read (${watchSelectedIds.length})`\n          }\n        </button>\n      </div>\n\n      <div className="space-y-2">\n        {notifications.filter(n => !n.isRead).map((notification) => (\n          <label key={notification.id} className="flex items-center space-x-2 p-2 hover:bg-gray-50 rounded">\n            <input\n              type="checkbox"\n              value={notification.id}\n              {...register(\'selectedIds\')}\n              className="w-4 h-4 text-blue-600"\n            />\n            <span className="text-sm">{notification.title}</span>\n          </label>\n        ))}\n      </div>\n    </form>\n  )\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"curl-example",children:"cURL Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'curl -X POST https://ring.ck.ua/api/notifications/read-all \\\n  -H "Content-Type: application/json" \\\n  -H "Cookie: next-auth.session-token=your-session-token"\n'})}),"\n",(0,i.jsx)(n.h2,{id:"business-logic",children:"Business Logic"}),"\n",(0,i.jsx)(n.p,{children:"The endpoint performs the following operations:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Authentication Check"}),": Verifies user session and extracts user ID"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Database Query"}),": Finds all unread notifications for the user"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bulk Update"}),": Marks all found notifications as read with timestamps"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Count Tracking"}),": Counts the number of notifications that were updated"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Response"}),": Returns success confirmation with count"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"database-operations",children:"Database Operations"}),"\n",(0,i.jsx)(n.h3,{id:"query-pattern",children:"Query Pattern"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// Firestore query to find unread notifications\nconst unreadNotifications = await db\n  .collection('notifications')\n  .where('userId', '==', userId)\n  .where('isRead', '==', false)\n  .get()\n\n// Batch update all notifications\nconst batch = db.batch()\nunreadNotifications.docs.forEach(doc => {\n  batch.update(doc.ref, {\n    isRead: true,\n    readAt: new Date(),\n    updatedAt: new Date()\n  })\n})\n\nawait batch.commit()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"database-schema-impact",children:"Database Schema Impact"}),"\n",(0,i.jsx)(n.h4,{id:"before-update",children:"Before Update"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'[\n  {\n    "id": "notification1",\n    "userId": "user123",\n    "title": "New message",\n    "isRead": false,\n    "createdAt": "2024-01-15T10:30:00Z",\n    "updatedAt": "2024-01-15T10:30:00Z"\n  },\n  {\n    "id": "notification2", \n    "userId": "user123",\n    "title": "Opportunity update",\n    "isRead": false,\n    "createdAt": "2024-01-15T11:00:00Z",\n    "updatedAt": "2024-01-15T11:00:00Z"\n  }\n]\n'})}),"\n",(0,i.jsx)(n.h4,{id:"after-bulk-update",children:"After Bulk Update"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'[\n  {\n    "id": "notification1",\n    "userId": "user123", \n    "title": "New message",\n    "isRead": true,\n    "readAt": "2024-01-15T14:22:00Z",\n    "createdAt": "2024-01-15T10:30:00Z",\n    "updatedAt": "2024-01-15T14:22:00Z"\n  },\n  {\n    "id": "notification2",\n    "userId": "user123",\n    "title": "Opportunity update", \n    "isRead": true,\n    "readAt": "2024-01-15T14:22:00Z",\n    "createdAt": "2024-01-15T11:00:00Z",\n    "updatedAt": "2024-01-15T14:22:00Z"\n  }\n]\n'})}),"\n",(0,i.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Authentication Required"}),": Only authenticated users can mark notifications as read"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"User Isolation"}),": Users can only mark their own notifications as read"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bulk Operation Limits"}),": No artificial limits, but database batch operations are used for efficiency"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rate Limiting"}),": Prevents abuse of bulk operations"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"performance-notes",children:"Performance Notes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Batch Operations"}),": Uses Firestore batch writes for efficient bulk updates"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Query Optimization"}),": Only queries unread notifications to minimize data transfer"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Transaction Safety"}),": Uses atomic operations to ensure data consistency"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Count Optimization"}),": Returns the actual count of updated notifications"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"rate-limiting",children:"Rate Limiting"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"User-based"}),": 5 requests per minute per authenticated user (due to bulk nature)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Global"}),": 100 requests per minute across all users"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.p,{children:"The API implements comprehensive error handling:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Authentication errors return 401 status"}),"\n",(0,i.jsx)(n.li,{children:"Database errors return 500 status with user-friendly messages"}),"\n",(0,i.jsx)(n.li,{children:"Successful operations return count of affected notifications"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"real-time-updates-integration",children:"Real-time Updates Integration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// WebSocket integration for real-time notification updates\nimport { useEffect } from 'react'\nimport { useWebSocket } from '@/hooks/useWebSocket'\n\nfunction NotificationSystem() {\n  const { socket } = useWebSocket()\n  const [notifications, setNotifications] = useState<Notification[]>([])\n\n  useEffect(() => {\n    if (!socket) return\n\n    // Listen for bulk read events\n    socket.on('notifications:bulk-read', (data: { userId: string, count: number }) => {\n      setNotifications(prev => \n        prev.map(notification => ({\n          ...notification,\n          isRead: true,\n          readAt: new Date().toISOString()\n        }))\n      )\n    })\n\n    return () => {\n      socket.off('notifications:bulk-read')\n    }\n  }, [socket])\n\n  return (\n    <div className=\"notification-system\">\n      {/* Notification components */}\n    </div>\n  )\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,i.jsx)(n.h3,{id:"unit-test-example",children:"Unit Test Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { POST } from '@/app/api/notifications/read-all/route'\nimport { NextRequest } from 'next/server'\n\n// Mock authentication and services\njest.mock('@/auth')\njest.mock('@/services/notifications/notification-service')\n\ndescribe('/api/notifications/read-all', () => {\n  it('should mark all notifications as read successfully', async () => {\n    // Mock authenticated session\n    (getServerAuthSession as jest.Mock).mockResolvedValue({\n      user: { id: 'user123', role: 'member' }\n    })\n\n    // Mock service to return count\n    (markAllNotificationsAsRead as jest.Mock).mockResolvedValue(3)\n\n    const request = new NextRequest('http://localhost:3000/api/notifications/read-all', {\n      method: 'POST'\n    })\n\n    const response = await POST(request)\n    const data = await response.json()\n\n    expect(response.status).toBe(200)\n    expect(data.success).toBe(true)\n    expect(data.markedCount).toBe(3)\n    expect(data.message).toBe('3 notifications marked as read')\n  })\n\n  it('should handle zero notifications gracefully', async () => {\n    (markAllNotificationsAsRead as jest.Mock).mockResolvedValue(0)\n\n    const request = new NextRequest('http://localhost:3000/api/notifications/read-all', {\n      method: 'POST'\n    })\n\n    const response = await POST(request)\n    const data = await response.json()\n\n    expect(response.status).toBe(200)\n    expect(data.markedCount).toBe(0)\n    expect(data.message).toBe('0 notifications marked as read')\n  })\n})\n"})}),"\n",(0,i.jsx)(n.h3,{id:"integration-test",children:"Integration Test"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport NotificationHeader from '@/components/NotificationHeader'\n\n// Mock notifications data\nconst mockNotifications = [\n  { id: '1', title: 'Test 1', isRead: false, message: 'Test message 1', createdAt: '2024-01-15T10:30:00Z', type: 'info' as const },\n  { id: '2', title: 'Test 2', isRead: false, message: 'Test message 2', createdAt: '2024-01-15T11:00:00Z', type: 'info' as const },\n  { id: '3', title: 'Test 3', isRead: true, message: 'Test message 3', createdAt: '2024-01-15T09:00:00Z', type: 'info' as const }\n]\n\ndescribe('NotificationHeader Integration', () => {\n  it('should mark all notifications as read when button is clicked', async () => {\n    const onMarkAllAsRead = jest.fn()\n    \n    render(\n      <NotificationHeader \n        notifications={mockNotifications} \n        onMarkAllAsRead={onMarkAllAsRead}\n      />\n    )\n\n    // Should show 2 unread notifications\n    expect(screen.getByText('2 unread')).toBeInTheDocument()\n    \n    // Click mark all as read button\n    const button = screen.getByText('Mark All as Read (2)')\n    fireEvent.click(button)\n\n    // Should call the callback\n    await waitFor(() => {\n      expect(onMarkAllAsRead).toHaveBeenCalled()\n    })\n  })\n})\n"})}),"\n",(0,i.jsx)(n.h2,{id:"related-endpoints",children:"Related Endpoints"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/api/notifications/list",children:(0,i.jsx)(n.code,{children:"GET /api/notifications"})})," - List user notifications"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/api/notifications/read",children:(0,i.jsx)(n.code,{children:"POST /api/notifications/[id]/read"})})," - Mark specific notification as read"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/api/notifications/preferences",children:(0,i.jsx)(n.code,{children:"GET /api/notifications/preferences"})})," - Get notification preferences"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/api/notifications/preferences",children:(0,i.jsx)(n.code,{children:"PUT /api/notifications/preferences"})})," - Update notification preferences"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(96540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);