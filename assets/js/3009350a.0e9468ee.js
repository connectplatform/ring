"use strict";(self.webpackChunkring_docs=self.webpackChunkring_docs||[]).push([[9818],{28453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>a});var s=n(96540);const t={},l=s.createContext(t);function r(e){const i=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(l.Provider,{value:i},e.children)}},92280:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"libraries/FIRESTORE_RULES","title":"Firestore Rules Reference","description":"This document provides a comprehensive reference for the Firestore security rules used in the Ring App project.","source":"@site/docs/en/libraries/FIRESTORE_RULES.md","sourceDirName":"libraries","slug":"/libraries/FIRESTORE_RULES","permalink":"/ring/docs/libraries/FIRESTORE_RULES","draft":false,"unlisted":false,"editUrl":"https://github.com/connectplatform/ring/ring-docs/tree/main/docs/en/libraries/FIRESTORE_RULES.md","tags":[],"version":"current","lastUpdatedAt":1750331037000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"FIRESTORE REFERENCE","permalink":"/ring/docs/libraries/FIRESTORE_SETUP"},"next":{"title":"Authentication","permalink":"/ring/docs/libraries/authentication-library"}}');var t=n(74848),l=n(28453);const r={},a="Firestore Rules Reference",c={},o=[{value:"Overview",id:"overview",level:2},{value:"Helper Functions",id:"helper-functions",level:2},{value:"User Role Checks",id:"user-role-checks",level:3},{value:"Visibility Access Check",id:"visibility-access-check",level:3},{value:"Collection Rules",id:"collection-rules",level:2},{value:"Opportunities Collection",id:"opportunities-collection",level:3},{value:"Access Levels for Opportunities",id:"access-levels-for-opportunities",level:4},{value:"Entities Collection",id:"entities-collection",level:3},{value:"Access Levels for Entities",id:"access-levels-for-entities",level:4},{value:"User Profiles Collection",id:"user-profiles-collection",level:3},{value:"User Settings Collection",id:"user-settings-collection",level:3},{value:"Contact Forms Collection",id:"contact-forms-collection",level:3},{value:"Chats Collection",id:"chats-collection",level:3},{value:"Important Notes",id:"important-notes",level:2}];function d(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"firestore-rules-reference",children:"Firestore Rules Reference"})}),"\n",(0,t.jsx)(i.p,{children:"This document provides a comprehensive reference for the Firestore security rules used in the Ring App project."}),"\n",(0,t.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(i.p,{children:"These rules implement a granular access control system based on user roles and content visibility. The main roles are:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Admin"}),"\n",(0,t.jsx)(i.li,{children:"Classified (VIP)"}),"\n",(0,t.jsx)(i.li,{children:"Member"}),"\n",(0,t.jsx)(i.li,{children:"Subscriber"}),"\n",(0,t.jsx)(i.li,{children:"Unauthenticated"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Content visibility levels:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Public"}),"\n",(0,t.jsx)(i.li,{children:"Subscriber"}),"\n",(0,t.jsx)(i.li,{children:"Members Only"}),"\n",(0,t.jsx)(i.li,{children:"Classified"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"helper-functions",children:"Helper Functions"}),"\n",(0,t.jsx)(i.h3,{id:"user-role-checks",children:"User Role Checks"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-javascript",children:"function isAdmin() {\n  return request.auth != null && request.auth.token.role == 'admin';\n}\n\nfunction isAuthenticated() {\n  return request.auth != null;\n}\n\nfunction isClassified() {\n  return request.auth != null && request.auth.token.role == 'confidential';\n}\n\nfunction isMember() {\n  return request.auth != null && (request.auth.token.role == 'member' || request.auth.token.role == 'confidential' || isAdmin());\n}\n\nfunction isSubscriber() {\n  return request.auth != null && (request.auth.token.role == 'subscriber' || isMember());\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"visibility-access-check",children:"Visibility Access Check"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-javascript",children:"function canAccessVisibility(visibility) {\n  return (visibility == 'public') ||\n         (visibility == 'subscriber' && isSubscriber()) ||\n         (visibility == 'member' && isMember()) ||\n         (visibility == 'confidential' && isClassified()) ||\n         isAdmin();\n}\n"})}),"\n",(0,t.jsx)(i.h2,{id:"collection-rules",children:"Collection Rules"}),"\n",(0,t.jsx)(i.h3,{id:"opportunities-collection",children:"Opportunities Collection"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-javascript",children:"match /opportunities/{opportunityId} {\n  // Allow read based on visibility and user role\n  allow read: if canAccessVisibility(resource.data.visibility);\n\n  // Function to determine which fields a user can access\n  function getAccessibleFields() {\n    let baseFields = ['id', 'type', 'title', 'briefDescription', 'category', 'tags', 'visibility'];\n    let memberFields = baseFields.concat(['fullDescription', 'createdBy', 'dateCreated', 'dateUpdated', 'expirationDate', 'status', 'location', 'budget', 'requiredSkills', 'requiredDocuments', 'attachments']);\n    let confidentialFields = memberFields.concat(['organizationId', 'contactInfo']);\n\n    return isClassified() || isAdmin() ? confidentialFields :\n           isMember() ? memberFields :\n           isSubscriber() ? baseFields :\n           [];\n  }\n\n  // Allow create with proper fields and visibility\n  allow create: if isAuthenticated() \n                && request.resource.data.visibility in ['public', 'subscriber', 'member', 'confidential']\n                && request.resource.data.keys().hasAll(['title', 'briefDescription', 'fullDescription', 'createdBy', 'organizationId', 'dateCreated', 'dateUpdated', 'expirationDate', 'status', 'type', 'category', 'tags', 'location', 'visibility']);\n\n  // Allow update with proper fields and visibility\n  allow update: if (request.auth.uid == resource.data.createdBy || isAdmin())\n                && request.resource.data.visibility in ['public', 'subscriber', 'member', 'confidential']\n                && request.resource.data.keys().hasAll(['title', 'briefDescription', 'fullDescription', 'createdBy', 'organizationId', 'dateCreated', 'dateUpdated', 'expirationDate', 'status', 'type', 'category', 'tags', 'location', 'visibility']);\n\n  // Allow delete only by creator or admin\n  allow delete: if request.auth.uid == resource.data.createdBy || isAdmin();\n\n  // Allow read only for accessible fields\n  allow read: if request.resource.data.keys().hasOnly(getAccessibleFields());\n}\n"})}),"\n",(0,t.jsx)(i.h4,{id:"access-levels-for-opportunities",children:"Access Levels for Opportunities"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Classified Users and Admins"}),": Can see all information."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Members"}),": Can see opportunity details, types, tags, categories, documents, and author name."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Subscribers"}),": Can only view opportunity name, briefDescription, category, and tags."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Unauthenticated"}),": Can only see public opportunities with limited information."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"entities-collection",children:"Entities Collection"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-javascript",children:"match /entities/{entityId} {\n  // Function to determine which fields a user can access\n  function getAccessibleFields() {\n    let baseFields = ['id', 'type', 'shortDescription', 'tags', 'visibility'];\n    let memberFields = baseFields.concat(['name', 'fullDescription', 'logo', 'website', 'contactEmail', 'phoneNumber', 'socialMedia', 'foundedYear', 'employeeCount', 'industries', 'services', 'certifications', 'partnerships', 'upcomingEvents', 'gallery']);\n    let confidentialFields = memberFields.concat(['location', 'addedBy', 'dateAdded', 'lastUpdated', 'memberSince']);\n\n    return isClassified() || isAdmin() ? confidentialFields :\n           isMember() ? memberFields :\n           isSubscriber() ? baseFields :\n           [];\n  }\n\n  // Allow read based on visibility and accessible fields\n  allow read: if canAccessVisibility(resource.data.visibility)\n              && request.resource.data.keys().hasOnly(getAccessibleFields());\n\n  // Allow create and update only by admin with all required fields\n  allow create, update: if isAdmin()\n                        && request.resource.data.keys().hasAll(['name', 'type', 'shortDescription', 'location', 'visibility', 'dateAdded', 'lastUpdated'])\n                        && request.resource.data.visibility in ['public', 'subscriber', 'member', 'confidential'];\n\n  // Allow delete only by admin\n  allow delete: if isAdmin();\n}\n"})}),"\n",(0,t.jsx)(i.h4,{id:"access-levels-for-entities",children:"Access Levels for Entities"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Classified Users and Admins"}),": Can see all information, including name and location."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Members"}),": Can see everything except location and some administrative fields."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Subscribers"}),": Can only see basic information (id, type, shortDescription, tags, visibility)."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Unauthenticated"}),": Can only see public entities with limited information."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"user-profiles-collection",children:"User Profiles Collection"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-javascript",children:"match /userProfiles/{userId} {\n  allow read: if isAuthenticated() && (request.auth.uid == userId || isAdmin());\n  allow create, update: if isAuthenticated() && request.auth.uid == userId\n                        && request.resource.data.keys().hasAll(['email', 'name', 'role', 'organizationId', 'memberSince', 'lastLogin', 'isVerified'])\n                        && request.resource.data.email == request.auth.token.email;\n  allow delete: if isAdmin();\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"user-settings-collection",children:"User Settings Collection"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-javascript",children:"match /userSettings/{userId} {\n  allow read, write: if request.auth.uid == userId || isAdmin();\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"contact-forms-collection",children:"Contact Forms Collection"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-javascript",children:"match /contactForms/{formId} {\n  allow create: if request.resource.data.keys().hasAll(['name', 'email', 'message']);\n  allow read, update, delete: if isAdmin();\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"chats-collection",children:"Chats Collection"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-javascript",children:"match /chats/{chatId} {\n  allow read, write: if request.auth.uid in resource.data.participants || isAdmin();\n}\n"})}),"\n",(0,t.jsx)(i.h2,{id:"important-notes",children:"Important Notes"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"These rules implement a hierarchical access system where higher-level roles have access to all lower-level content."}),"\n",(0,t.jsx)(i.li,{children:"Entity names are hidden in OpportunityDetails and Opportunities for subscribers."}),"\n",(0,t.jsx)(i.li,{children:"Only confidential users and admins can see confidential information such as Entity name and location in both Entities and Opportunities."}),"\n",(0,t.jsx)(i.li,{children:"Ensure that user roles are correctly set in authentication tokens when users sign up or their roles change."}),"\n",(0,t.jsx)(i.li,{children:"Always test these rules thoroughly to ensure they provide the correct level of access for each user type and protect your data as intended."}),"\n"]})]})}function u(e={}){const{wrapper:i}={...(0,l.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);