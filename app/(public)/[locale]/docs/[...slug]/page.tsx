import React from 'react'
import { MDXRemote } from 'next-mdx-remote/rsc'
import { notFound, redirect } from 'next/navigation'
import { connection } from 'next/server'
import fs from 'fs'
import path from 'path'
import matter from 'gray-matter'
import remarkGfm from 'remark-gfm'
import rehypeShiki from '@shikijs/rehype'
import type { Metadata } from 'next'
import { resolveDocFilePath } from '@/lib/docs/resolve-doc-file-path'

// Route segment configuration
// dynamicParams = true allows routes not pre-generated by generateStaticParams
// This prevents 404s on first load in development mode

// Use 'auto' for optimal static/dynamic balance
// In dev mode, this ensures proper server rendering without blocking on missing static paths

// Revalidate every hour in production for fresh content
import { Callout } from '@/components/docs/callout'
import { Steps, Step } from '@/components/docs/steps'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Mermaid } from '@/components/docs/mermaid'
import { MindMap } from '@/components/docs/mindmap'
import { Code } from '@/components/docs/code'
import { InlineCode } from '@/components/docs/inline-code'
import { RingAISynapseFlow } from '@/components/docs/ring-ai-synapse-flow'

// MDX components mapping
const components = {
  // Custom components
  Callout,
  Steps,
  Step,
  Card,
  CardHeader,
  CardTitle,
  CardDescription,
  CardContent,
  Mermaid,
  MindMap,
  Code,
  RingAISynapseFlow,
  // HTML elements with styling - using semantic color tokens for Tailwind 4
  // Enhanced heading hierarchy with scroll anchors
  h1: ({ children, ...props }: any) => (
    <h1 className="text-4xl font-bold tracking-tight mb-6 mt-8 first:mt-0 text-foreground scroll-mt-20" {...props}>{children}</h1>
  ),
  h2: ({ children, ...props }: any) => (
    <h2 className="text-3xl font-semibold tracking-tight mb-4 mt-10 first:mt-0 pb-2 border-b border-border text-foreground scroll-mt-20" {...props}>{children}</h2>
  ),
  h3: ({ children, ...props }: any) => (
    <h3 className="text-2xl font-semibold mb-3 mt-8 text-foreground scroll-mt-20" {...props}>{children}</h3>
  ),
  h4: ({ children, ...props }: any) => (
    <h4 className="text-xl font-semibold mb-2 mt-6 text-foreground scroll-mt-20" {...props}>{children}</h4>
  ),
  h5: ({ children, ...props }: any) => (
    <h5 className="text-lg font-semibold mb-2 mt-4 text-foreground scroll-mt-20" {...props}>{children}</h5>
  ),
  h6: ({ children, ...props }: any) => (
    <h6 className="text-base font-semibold mb-2 mt-4 text-foreground scroll-mt-20" {...props}>{children}</h6>
  ),
  p: ({ children, ...props }: any) => (
    <p className="text-base leading-7 text-muted-foreground mb-4 [&:not(:first-child)]:mt-4" {...props}>{children}</p>
  ),
  ul: ({ children, ...props }: any) => (
    <ul className="my-4 ml-6 list-disc [&>li]:mt-2 text-muted-foreground" {...props}>{children}</ul>
  ),
  ol: ({ children, ...props }: any) => (
    <ol className="my-4 ml-6 list-decimal [&>li]:mt-2 text-muted-foreground" {...props}>{children}</ol>
  ),
  li: ({ children, ...props }: any) => (
    <li className="leading-7" {...props}>{children}</li>
  ),
  // Tables
  table: ({ children, ...props }: any) => (
    <div className="my-6 w-full overflow-y-auto">
      <table className="w-full border-collapse text-sm" {...props}>{children}</table>
    </div>
  ),
  thead: ({ children, ...props }: any) => (
    <thead className="border-b border-border" {...props}>{children}</thead>
  ),
  tbody: ({ children, ...props }: any) => (
    <tbody className="[&_tr:last-child]:border-0" {...props}>{children}</tbody>
  ),
  tr: ({ children, ...props }: any) => (
    <tr className="border-b border-border transition-colors hover:bg-muted/50" {...props}>{children}</tr>
  ),
  th: ({ children, ...props }: any) => (
    <th className="h-12 px-4 text-left align-middle font-medium text-foreground" {...props}>{children}</th>
  ),
  td: ({ children, ...props }: any) => (
    <td className="p-4 align-middle text-muted-foreground" {...props}>{children}</td>
  ),
  // Images
  img: ({ alt, ...props }: any) => (
    // eslint-disable-next-line @next/next/no-img-element
    <img className="rounded-lg border border-border my-6" alt={alt || ''} {...props} />
  ),
  code: ({ children, className, ...props }: any) => {
    const isInline = !className?.includes('language-')
    return isInline ? (
      <InlineCode {...props}>{children}</InlineCode>
    ) : (
      <code className={className} {...props}>{children}</code>
    )
  },
  blockquote: ({ children, ...props }: any) => (
    <blockquote className="mt-6 border-l-4 border-primary pl-6 italic text-muted-foreground [&>p]:text-muted-foreground" {...props}>
      {children}
    </blockquote>
  ),
  strong: ({ children, ...props }: any) => (
    <strong className="font-semibold text-foreground" {...props}>{children}</strong>
  ),
  em: ({ children, ...props }: any) => (
    <em className="italic" {...props}>{children}</em>
  ),
  a: ({ children, href, ...props }: any) => (
    <a href={href} className="text-primary hover:underline font-medium" {...props}>{children}</a>
  ),
  hr: ({ ...props }: any) => (
    <hr className="my-8 border-gray-200 dark:border-gray-800" {...props} />
  ),
}

interface PageProps {
  params: Promise<{
    locale: string
    slug: string[]
  }>
}

// Generate metadata from frontmatter for SEO
export async function generateMetadata({ params }: PageProps): Promise<Metadata> {
  const { locale, slug } = await params
  const { filePath, redirect: redirectPath } = resolveDocFilePath(locale, slug)

  // If redirect is needed, return basic metadata
  if (redirectPath || !filePath) {
    return {
      title: 'Ring Platform Documentation',
      description: 'Complete documentation for the Ring Platform'
    }
  }

  try {
    if (!fs.existsSync(filePath)) {
      return {
        title: 'Documentation Not Found',
        description: 'The requested documentation page could not be found.'
      }
    }

    const fileContents = fs.readFileSync(filePath, 'utf8')
    const { data } = matter(fileContents)

    return {
      title: data.title || 'Ring Platform Documentation',
      description: data.description || 'Complete documentation for the Ring Platform - a free open-source platform for solving human needs collectively with AI orchestration.',
      keywords: data.keywords || ['Ring Platform', 'documentation', 'AI orchestration', 'open-source'],
      openGraph: {
        title: data.title || 'Ring Platform Documentation',
        description: data.description || 'Complete documentation for the Ring Platform - a free open-source platform for solving human needs collectively with AI orchestration.',
        type: 'article',
      },
      twitter: {
        card: 'summary_large_image',
        title: data.title || 'Ring Platform Documentation',
        description: data.description || 'Complete documentation for the Ring Platform - a free open-source platform for solving human needs collectively with AI orchestration.',
      },
    }
  } catch (error) {
    console.error('Error generating metadata:', error)
    return {
      title: 'Ring Platform Documentation',
      description: 'Complete documentation for the Ring Platform - a free open-source platform for solving human needs collectively with AI orchestration.'
    }
  }
}

export default async function DocPage({ params }: PageProps) {
  // Next.js 16: opt out of prerendering â€” @shikijs/vscode-textmate tokenizer
  // uses Date.now() internally for timeout tracking during syntax highlighting,
  // which triggers the prerender-current-time error. Third-party, can't patch.
  await connection()

  const { locale, slug } = await params
  const { filePath, redirect: redirectPath } = resolveDocFilePath(locale, slug)

  // Handle canonical URL redirect (e.g., /docs/section/index -> /docs/section)
  if (redirectPath) {
    redirect(redirectPath)
  }

  if (!filePath) {
    notFound()
  }

  try {
    // Check if file exists
    if (!fs.existsSync(filePath)) {
      console.error(`Doc file not found: ${filePath}`)
      notFound()
    }

    // Read the MDX file
    const fileContents = fs.readFileSync(filePath, 'utf8')

    // Parse frontmatter
    const { content } = matter(fileContents)

    return (
      <div className="w-full h-full py-8 px-4 md:px-6 lg:px-8">
        <div className="w-full max-w-full">
          <MDXRemote
            source={content}
            components={components}
            options={{
              mdxOptions: {
                remarkPlugins: [remarkGfm],
                rehypePlugins: [
                  [rehypeShiki, {
                    themes: {
                      light: 'nord',
                      dark: 'tokyo-night',
                    },
                    defaultColor: false,
                  }],
                ],
              },
            }}
          />
        </div>
      </div>
    )
  } catch (error) {
    console.error('Error loading doc:', error)
    notFound()
  }
}

// Generate static params for all docs
export async function generateStaticParams() {
  const docsRoot = path.join(process.cwd(), 'docs', 'content')
  const locales = ['en', 'ru', 'uk']
  const params: { locale: string; slug: string[] }[] = []

  for (const locale of locales) {
    const localePath = path.join(docsRoot, locale, 'library')

    function scanDir(dir: string, currentSlug: string[] = []): void {
      if (!fs.existsSync(dir)) return

      const items = fs.readdirSync(dir)

      for (const item of items) {
        const fullPath = path.join(dir, item)
        const stat = fs.statSync(fullPath)

        if (stat.isDirectory()) {
          // Check if this directory has an index.mdx file
          const indexPath = path.join(fullPath, 'index.mdx')
          if (fs.existsSync(indexPath)) {
            params.push({ locale, slug: [...currentSlug, item] })
          }
          // Continue scanning subdirectories
          scanDir(fullPath, [...currentSlug, item])
        } else if (item.endsWith('.mdx') && item !== 'index.mdx') {
          // For non-index .mdx files, create slugs for each file
          const slug = [...currentSlug, item.replace('.mdx', '')]
          params.push({ locale, slug })
        }
      }
    }

    scanDir(localePath)
  }

  return params
}
