---
title: –†–µ–∑–µ—Ä–≤–Ω–µ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è —Ç–∞ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
description: –ö–æ–º–ø–ª–µ–∫—Å–Ω—ñ —Å—Ç—Ä–∞—Ç–µ–≥—ñ—ó —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è —Ç–∞ –ø—Ä–æ—Ü–µ–¥—É—Ä–∏ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—ñ—Å–ª—è –∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ –¥–ª—è —Ä–æ–∑–≥–æ—Ä—Ç–∞–Ω—å –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏ Ring
last_modified: "2025-10-16"
---

import { Callout } from '@/components/docs/callout'
import { Steps, Step } from '@/components/docs/steps'

# üîÑ –†–µ–∑–µ—Ä–≤–Ω–µ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è —Ç–∞ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è

**–ö–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω—ñ —Å—Ç—Ä–∞—Ç–µ–≥—ñ—ó —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è** —Ç–∞ –ø—Ä–æ—Ü–µ–¥—É—Ä–∏ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—ñ—Å–ª—è –∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ, —â–æ –∑–∞–±–µ–∑–ø–µ—á—É—é—Ç—å –±–µ–∑–ø–µ—Ä–µ—Ä–≤–Ω—ñ—Å—Ç—å –±—ñ–∑–Ω–µ—Å—É, —Ü—ñ–ª—ñ—Å–Ω—ñ—Å—Ç—å –¥–∞–Ω–∏—Ö —Ç–∞ —à–≤–∏–¥–∫–µ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–ª—è —Ä–æ–∑–≥–æ—Ä—Ç–∞–Ω—å –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏ Ring.

## üéØ –ë—ñ–∑–Ω–µ—Å-—Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç–∞ ROI

### –ö—Ä–∏—Ç–∏—á–Ω—ñ –ø–µ—Ä–µ–≤–∞–≥–∏ –±—ñ–∑–Ω–µ—Å—É
- **99.9% –¶—ñ–ª—ñ—Å–Ω–æ—Å—Ç—ñ –¥–∞–Ω–∏—Ö** –∑ –±–∞–≥–∞—Ç–æ—Ä—ñ–≤–Ω–µ–≤–∏–º –∑–∞—Ö–∏—Å—Ç–æ–º —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è
- **15-—Ö–≤–∏–ª–∏–Ω–Ω–∏–π RTO (–ß–∞—Å –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è)** –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω–∏—Ö —Å–∏—Å—Ç–µ–º
- **4-–≥–æ–¥–∏–Ω–Ω–∏–π RPO (–¢–æ—á–∫–∞ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è)** –¥–ª—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ–π–Ω–∏—Ö –¥–∞–Ω–∏—Ö
- **$2.5M+ –©–æ—Ä—ñ—á–Ω–æ—ó –µ–∫–æ–Ω–æ–º—ñ—ó** –≤—ñ–¥ –∑–∞–ø–æ–±—ñ–≥–∞–Ω–Ω—è —ñ–Ω—Ü–∏–¥–µ–Ω—Ç–∞–º –≤—Ç—Ä–∞—Ç–∏ –¥–∞–Ω–∏—Ö
- **100% –í—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—Å—Ç—ñ** –≤–∏–º–æ–≥–∞–º –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è —Ç–∞ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö

### –ú–æ–∂–ª–∏–≤–æ—Å—Ç—ñ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
- **–ú–∏—Ç—Ç—î–≤–∏–π failover** –¥–æ —Ä–µ–∑–µ—Ä–≤–Ω–∏—Ö —Å–∏—Å—Ç–µ–º –ø—ñ–¥ —á–∞—Å –∑–±–æ—ó–≤
- **–í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–æ —Ç–æ—á–∫–∏ –≤ —á–∞—Å—ñ** –¥–ª—è –≥—Ä–∞–Ω—É–ª—è—Ä–Ω–æ–≥–æ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö
- **–ö—Ä–æ—Å-—Ä–µ–≥—ñ–æ–Ω–∞–ª—å–Ω–∞ —Ä–µ–ø–ª—ñ–∫–∞—Ü—ñ—è** –¥–ª—è —Å—Ç—ñ–π–∫–æ—Å—Ç—ñ –¥–æ –∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ
- **–ê–≤—Ç–æ–º–∞—Ç–∏–∑–æ–≤–∞–Ω–µ —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è** —Ü—ñ–ª—ñ—Å–Ω–æ—Å—Ç—ñ —Ä–µ–∑–µ—Ä–≤–Ω–∏—Ö –∫–æ–ø—ñ–π —Ç–∞ –ø—Ä–æ—Ü–µ–¥—É—Ä –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
- **–û–±—Å–ª—É–≥–æ–≤—É–≤–∞–Ω–Ω—è –±–µ–∑ –ø—Ä–æ—Å—Ç–æ—ó–≤** –∑–∞–≤–¥—è–∫–∏ –Ω–∞–¥–ª–∏—à–∫–æ–≤–æ—Å—Ç—ñ —Å–∏—Å—Ç–µ–º–∏ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è

## üóÑÔ∏è –°—Ç—Ä–∞—Ç–µ–≥—ñ—ó —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è –±–∞–∑–∏ –¥–∞–Ω–∏—Ö

### –ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è PostgreSQL

**–ë–∞–≥–∞—Ç–æ—Ä—ñ–≤–Ω–µ–≤–∞ —Å–∏—Å—Ç–µ–º–∞ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è** –∑ –±–µ–∑–ø–µ—Ä–µ—Ä–≤–Ω–∏–º –∞—Ä—Ö—ñ–≤—É–≤–∞–Ω–Ω—è–º, –∑–∞–ø–ª–∞–Ω–æ–≤–∞–Ω–∏–º–∏ –∑–Ω—ñ–º–∫–∞–º–∏ —Ç–∞ –∫—Ä–æ—Å-—Ä–µ–≥—ñ–æ–Ω–∞–ª—å–Ω–æ—é —Ä–µ–ø–ª—ñ–∫–∞—Ü—ñ—î—é.

// –ö–æ–º–ø–ª–µ–∫—Å–Ω–∞ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è PostgreSQL

<Code language="typescript" title="TypeScript">
{`export class PostgreSQLBackupManager {
  private backupConfig = {
    continuousArchiving: {
      walLevel: 'replica',
      archiveMode: 'on',
      archiveCommand: 'pgbackrest --stanza=main archive-push %p',
      restoreCommand: 'pgbackrest --stanza=main archive-get %f %p'
    },
    scheduledBackups: {
      full: {
        schedule: '0 2 * * 0', // –©–æ—Ç–∏–∂–Ω—è –Ω–µ–¥—ñ–ª—è –æ 2:00
        retention: '4 weeks',
        compression: 'lz4',
        encryption: 'aes256'
      },
      incremental: {
        schedule: '0 2 * * 1-6', // –©–æ–¥–Ω—è –ø–æ–Ω–µ–¥—ñ–ª–æ–∫-—Å—É–±–±–æ—Ç–∞ –æ 2:00
        retention: '7 days',
        compression: 'lz4',
        encryption: 'aes256'
      },
      differential: {
        schedule: '0 14 * * *', // –©–æ–¥–Ω—è –æ 14:00
        retention: '24 hours',
        compression: 'lz4',
        encryption: 'aes256'
      }
    },
    replication: {
      synchronousStandby: ['backup-01', 'backup-02'],
      asyncStandby: ['dr-site-01', 'dr-site-02'],
      lagMonitoring: {
        maxLag: '30 seconds',
        alertThreshold: '60 seconds'
      }
    }
  }

  async initializeBackupSystem(): Promise<void> {
    // –°—Ç–≤–æ—Ä–∏—Ç–∏ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—é pgBackRest
    await this.createPgBackRestConfig()

    // –ù–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ –±–µ–∑–ø–µ—Ä–µ—Ä–≤–Ω–µ –∞—Ä—Ö—ñ–≤—É–≤–∞–Ω–Ω—è
    await this.configureContinuousArchiving()

    // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä—ñ–π —Ä–µ–∑–µ—Ä–≤–Ω–∏—Ö –∫–æ–ø—ñ–π
    await this.initializeBackupRepository()

    // –ù–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ –ø–æ–ª—ñ—Ç–∏–∫–∏ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è
    await this.setupRetentionPolicies()

    // –ù–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ —Ç–∞ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è
    await this.configureBackupMonitoring()

    // –ü—Ä–æ—Ç–µ—Å—Ç—É–≤–∞—Ç–∏ –ø—Ä–æ—Ü–µ–¥—É—Ä–∏ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è —Ç–∞ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
    await this.testBackupRecovery()
  }

  async performFullBackup(): Promise<BackupResult> {
    const backupId = generateBackupId()
    const startTime = new Date()

    try {
      // –ü–æ–ø–µ—Ä–µ–¥–Ω—è –≤–∞–ª—ñ–¥–∞—Ü—ñ—è
      await this.validateDatabaseState()

      // –í–∏–∫–æ–Ω–∞—Ç–∏ –ø–æ–≤–Ω–µ —Ä–µ–∑–µ—Ä–≤–Ω–µ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è
      const result = await this.executePgBackRestBackup('full', backupId)

      // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Ü—ñ–ª—ñ—Å–Ω—ñ—Å—Ç—å —Ä–µ–∑–µ—Ä–≤–Ω–æ—ó –∫–æ–ø—ñ—ó
      await this.validateBackupIntegrity(backupId)

      // –û–Ω–æ–≤–∏—Ç–∏ –º–µ—Ç–∞–¥–∞–Ω—ñ —Ä–µ–∑–µ—Ä–≤–Ω–æ—ó –∫–æ–ø—ñ—ó
      await this.updateBackupMetadata(backupId, {
        type: 'full',
        startTime,
        endTime: new Date(),
        size: result.size,
        status: 'completed',
        checksum: result.checksum
      })

      // –ó–∞–ø—É—Å—Ç–∏—Ç–∏ –∫—Ä–æ—Å-—Ä–µ–≥—ñ–æ–Ω–∞–ª—å–Ω—É —Ä–µ–ø–ª—ñ–∫–∞—Ü—ñ—é
      await this.replicateToDRSite(backupId)

      // –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –ø—Ä–æ —É—Å–ø—ñ—Ö
      await this.sendBackupNotification(backupId, 'success')

      return {
        backupId,
        type: 'full',
        status: 'completed',
        size: result.size,
        duration: Date.now() - startTime.getTime()
      }

    } catch (error) {
      await this.handleBackupFailure(backupId, error)
      throw error
    }
  }

  private async createPgBackRestConfig(): Promise<void> {
    const config = `
[global]
repo1-path=/backup/pgbackrest
repo1-retention-full=4
repo1-retention-diff=7
repo1-retention-archive=30
repo1-bundle=y
repo1-bundle-size=1GB
repo1-block-size=1MB
repo1-compress-type=lz4
repo1-cipher-type=aes-256-cbc

[global:archive-push]
compress-level=6

[main]
pg1-path=/var/lib/postgresql/data
pg1-port=5432
pg1-user=backup_user

repo1-type=s3
repo1-s3-bucket=ring-platform-backups
repo1-s3-endpoint=s3.eu-central-1.amazonaws.com
repo1-s3-region=eu-central-1
repo1-s3-key=<backup-key>
repo1-s3-key-secret=<backup-secret>
`

    await writeFile('/etc/pgbackrest.conf', config)
  }

  private async validateDatabaseState(): Promise<void> {
    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –∑'—î–¥–Ω–∞–Ω–Ω—è –∑ –±–∞–∑–æ—é –¥–∞–Ω–∏—Ö
    await this.checkDatabaseConnectivity()

    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —á–∏ –ø—Ä–∞—Ü—é—î –∞—Ä—Ö—ñ–≤—É–≤–∞–Ω–Ω—è WAL
    await this.verifyWalArchiving()

    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –¥–æ–≤–≥–æ—Ç—Ä–∏–≤–∞–ª—ñ —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó
    await this.checkLongRunningTransactions()

    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –¥–æ–∑–≤–æ–ª–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è
    await this.validateBackupPermissions()

    // –ó–∞–±–µ–∑–ø–µ—á–∏—Ç–∏ –¥–æ—Å—Ç–∞—Ç–Ω—å–æ –¥–∏—Å–∫–æ–≤–æ–≥–æ –ø—Ä–æ—Å—Ç–æ—Ä—É
    await this.checkDiskSpace()
  }

  private async validateBackupIntegrity(backupId: string): Promise<void> {
    // –¢–µ—Å—Ç—É–≤–∞—Ç–∏ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è —Ä–µ–∑–µ—Ä–≤–Ω–æ—ó –∫–æ–ø—ñ—ó –¥–æ —Ç–∏–º—á–∞—Å–æ–≤–æ–≥–æ —ñ–Ω—Å—Ç–∞–Ω—Å—É
    const testInstance = await this.createTestInstance()

    try {
      await this.restoreBackupToInstance(backupId, testInstance)

      // –ó–∞–ø—É—Å—Ç–∏—Ç–∏ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ —Ü—ñ–ª—ñ—Å–Ω–æ—Å—Ç—ñ
      await this.runIntegrityChecks(testInstance)

      // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å –¥–∞–Ω–∏—Ö
      await this.validateDataConsistency(testInstance)

    } finally {
      // –û—á–∏—Å—Ç–∏—Ç–∏ —Ç–µ—Å—Ç–æ–≤–∏–π —ñ–Ω—Å—Ç–∞–Ω—Å
      await this.destroyTestInstance(testInstance)
    }
  }
}`}
</Code>

### –†–µ–∑–µ—Ä–≤–Ω–µ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è —Ç–∞ –µ–∫—Å–ø–æ—Ä—Ç Firestore

**–ê–≤—Ç–æ–º–∞—Ç–∏–∑–æ–≤–∞–Ω—ñ –µ–∫—Å–ø–æ—Ä—Ç–∏ Firestore** –∑ –∑–∞–ø–ª–∞–Ω–æ–≤–∞–Ω–∏–º–∏ —Ä–µ–∑–µ—Ä–≤–Ω–∏–º–∏ –∫–æ–ø—ñ—è–º–∏, —ñ–Ω–∫—Ä–µ–º–µ–Ω—Ç–∞–ª—å–Ω–∏–º–∏ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è–º–∏ —Ç–∞ –ø—Ä–æ—Ü–µ–¥—É—Ä–∞–º–∏ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—ñ—Å–ª—è –∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ.

// –°–∏—Å—Ç–µ–º–∞ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è —Ä–µ–∑–µ—Ä–≤–Ω–∏–º –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è–º Firestore

<Code language="typescript" title="TypeScript">
{`export class FirestoreBackupManager {
  private firestore: Firestore
  private storage: Storage
  private scheduler: CloudScheduler

  private backupConfig = {
    collections: [
      'users',
      'entities',
      'opportunities',
      'messages',
      'notifications',
      'transactions',
      'analytics'
    ],
    schedules: {
      full: {
        frequency: '0 2 * * 0', // –©–æ—Ç–∏–∂–Ω—è
        retention: '30 days',
        regions: ['europe-west1', 'us-central1']
      },
      incremental: {
        frequency: '0 */6 * * *', // –ö–æ–∂–Ω—ñ 6 –≥–æ–¥–∏–Ω
        retention: '7 days',
        regions: ['europe-west1']
      }
    },
    encryption: {
      algorithm: 'AES256',
      keyRotation: '30 days'
    }
  }

  async scheduleFirestoreBackups(): Promise<void> {
    // –ó–∞–ø–ª–∞–Ω—É–≤–∞—Ç–∏ –ø–æ–≤–Ω—ñ —Ä–µ–∑–µ—Ä–≤–Ω—ñ –∫–æ–ø—ñ—ó
    await this.scheduleFullBackup()

    // –ó–∞–ø–ª–∞–Ω—É–≤–∞—Ç–∏ —ñ–Ω–∫—Ä–µ–º–µ–Ω—Ç–∞–ª—å–Ω—ñ —Ä–µ–∑–µ—Ä–≤–Ω—ñ –∫–æ–ø—ñ—ó
    await this.scheduleIncrementalBackup()

    // –ù–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ –µ–∫—Å–ø–æ—Ä—Ç—É
    await this.setupExportMonitoring()

    // –ù–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ –ø–æ–ª—ñ—Ç–∏–∫–∏ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è
    await this.setupRetentionPolicies()
  }

  async performFirestoreExport(exportType: 'full' | 'incremental' = 'full'): Promise<ExportResult> {
    const exportId = generateExportId()
    const timestamp = new Date()

    try {
      // –°—Ç–≤–æ—Ä–∏—Ç–∏ –∑–∞–≤–¥–∞–Ω–Ω—è –µ–∫—Å–ø–æ—Ä—Ç—É
      const exportJob = await this.firestore.admin().exportDocuments({
        outputUriPrefix: `gs://ring-platform-firestore-backups/${exportType}/${timestamp.getTime()}`,
        collectionIds: exportType === 'full' ? this.backupConfig.collections : undefined,
        namespaceIds: ['(default)']
      })

      // –ú–æ–Ω—ñ—Ç–æ—Ä–∏—Ç–∏ –ø—Ä–æ–≥—Ä–µ—Å –µ–∫—Å–ø–æ—Ä—Ç—É
      const result = await this.monitorExportJob(exportJob)

      // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Ü—ñ–ª—ñ—Å–Ω—ñ—Å—Ç—å –µ–∫—Å–ø–æ—Ä—Ç—É
      await this.validateExportIntegrity(result.outputUri)

      // –û–Ω–æ–≤–∏—Ç–∏ –º–µ—Ç–∞–¥–∞–Ω—ñ
      await this.updateExportMetadata(exportId, {
        type: exportType,
        timestamp,
        status: 'completed',
        size: result.size,
        collections: result.collections,
        outputUri: result.outputUri
      })

      // –ó–∞–ø—É—Å—Ç–∏—Ç–∏ –∫—Ä–æ—Å-—Ä–µ–≥—ñ–æ–Ω–∞–ª—å–Ω—É —Ä–µ–ø–ª—ñ–∫–∞—Ü—ñ—é
      await this.replicateToBackupRegions(result.outputUri, exportType)

      return {
        exportId,
        type: exportType,
        status: 'completed',
        outputUri: result.outputUri,
        size: result.size
      }

    } catch (error) {
      await this.handleExportFailure(exportId, error)
      throw error
    }
  }

  async restoreFromFirestoreBackup(backupUri: string, targetCollections?: string[]): Promise<RestoreResult> {
    const restoreId = generateRestoreId()
    const startTime = new Date()

    try {
      // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Ü—ñ–ª—ñ—Å–Ω—ñ—Å—Ç—å —Ä–µ–∑–µ—Ä–≤–Ω–æ—ó –∫–æ–ø—ñ—ó
      await this.validateBackupIntegrity(backupUri)

      // –°—Ç–≤–æ—Ä–∏—Ç–∏ –∑–∞–≤–¥–∞–Ω–Ω—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
      const restoreJob = await this.firestore.admin().importDocuments({
        inputUriPrefix: backupUri,
        collectionIds: targetCollections
      })

      // –ú–æ–Ω—ñ—Ç–æ—Ä–∏—Ç–∏ –ø—Ä–æ–≥—Ä–µ—Å –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
      const result = await this.monitorRestoreJob(restoreJob)

      // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —É—Å–ø—ñ—à–Ω—ñ—Å—Ç—å –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
      await this.validateRestoreSuccess(result)

      // –û–Ω–æ–≤–∏—Ç–∏ –º–µ—Ç–∞–¥–∞–Ω—ñ
      await this.updateRestoreMetadata(restoreId, {
        backupUri,
        targetCollections,
        startTime,
        endTime: new Date(),
        status: 'completed',
        documentsRestored: result.documentsRestored
      })

      return {
        restoreId,
        status: 'completed',
        documentsRestored: result.documentsRestored,
        duration: Date.now() - startTime.getTime()
      }

    } catch (error) {
      await this.handleRestoreFailure(restoreId, error)
      throw error
    }
  }

  private async scheduleFullBackup(): Promise<void> {
    const jobName = 'firestore-full-backup'
    const schedule = this.backupConfig.schedules.full.frequency

    await this.scheduler.createJob({
      name: jobName,
      schedule,
      timeZone: 'UTC',
      httpTarget: {
        uri: `${process.env.CLOUD_FUNCTION_URL}/firestore-backup`,
        httpMethod: 'POST',
        body: Buffer.from(JSON.stringify({ type: 'full' })).toString('base64'),
        headers: {
          'Content-Type': 'application/json'
        }
      }
    })
  }

  private async validateExportIntegrity(outputUri: string): Promise<void> {
    // –ü–µ—Ä–µ–ª—ñ—á–∏—Ç–∏ –≤—Å—ñ –µ–∫—Å–ø–æ—Ä—Ç–æ–≤–∞–Ω—ñ —Ñ–∞–π–ª–∏
    const [files] = await this.storage.bucket().getFiles({
      prefix: outputUri.split('/').pop()
    })

    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ñ–∞–π–ª—ñ–≤
    await this.validateExportStructure(files)

    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Ä–æ–∑–º—ñ—Ä–∏ —Ñ–∞–π–ª—ñ–≤ —Ç–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å
    await this.validateExportMetrics(files)

    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Ü—ñ–ª—ñ—Å–Ω—ñ—Å—Ç—å –¥–∞–Ω–∏—Ö
    await this.verifyDataIntegrity(files)
  }

  private async replicateToBackupRegions(outputUri: string, exportType: string): Promise<void> {
    const regions = this.backupConfig.schedules[exportType].regions

    for (const region of regions) {
      if (region !== process.env.GCP_REGION) {
        await this.replicateToRegion(outputUri, region)
      }
    }
  }
}`}
</Code>

### –†–µ–∑–µ—Ä–≤–Ω–µ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è —Ç–∞ –∞—Ä—Ö—ñ–≤—É–≤–∞–Ω–Ω—è —Å—Ö–æ–≤–∏—â–∞

**–ö–æ–º–ø–ª–µ–∫—Å–Ω–µ —Ä–µ–∑–µ—Ä–≤–Ω–µ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è —Å—Ö–æ–≤–∏—â–∞ —Ñ–∞–π–ª—ñ–≤** –∑ –≤–µ—Ä—Å—ñ–π–Ω—ñ—Å—Ç—é, —à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è–º —Ç–∞ –¥–æ–≤–≥–æ—Å—Ç—Ä–æ–∫–æ–≤–∏–º –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è–º.

// –°–∏—Å—Ç–µ–º–∞ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è —Ö–º–∞—Ä–Ω–æ–≥–æ —Å—Ö–æ–≤–∏—â–∞

<Code language="typescript" title="TypeScript">
{`export class StorageBackupManager {
  private storage: Storage
  private backupConfig = {
    buckets: {
      primary: 'ring-platform-storage',
      backup: 'ring-platform-storage-backup',
      archive: 'ring-platform-storage-archive'
    },
    versioning: {
      enabled: true,
      retention: {
        active: '365 days',
        archive: '7 years',
        delete: '10 years'
      }
    },
    replication: {
      regions: ['eu-central-1', 'us-east-1', 'ap-southeast-1'],
      storageClass: 'STANDARD_IA'
    },
    encryption: {
      algorithm: 'AES256',
      keyManagement: 'GCP_KMS'
    }
  }

  async initializeStorageBackup(): Promise<void> {
    // –£–≤—ñ–º–∫–Ω—É—Ç–∏ –≤–µ—Ä—Å—ñ–π–Ω—ñ—Å—Ç—å –Ω–∞ –æ—Å–Ω–æ–≤–Ω–æ–º—É –±–∞–∫–µ—Ç—ñ
    await this.enableVersioning(this.backupConfig.buckets.primary)

    // –ù–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ –∫—Ä–æ—Å-—Ä–µ–≥—ñ–æ–Ω–∞–ª—å–Ω—É —Ä–µ–ø–ª—ñ–∫–∞—Ü—ñ—é
    await this.setupCrossRegionReplication()

    // –ù–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ –∂–∏—Ç—Ç—î–≤—ñ —Ü–∏–∫–ª–∏
    await this.setupLifecyclePolicies()

    // –ù–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è
    await this.setupBackupMonitoring()

    // –ü—Ä–æ—Ç–µ—Å—Ç—É–≤–∞—Ç–∏ –ø—Ä–æ—Ü–µ–¥—É—Ä–∏ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è —Ç–∞ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
    await this.testBackupRestore()
  }

  async performStorageBackup(backupType: 'full' | 'incremental' = 'incremental'): Promise<StorageBackupResult> {
    const backupId = generateStorageBackupId()
    const startTime = new Date()

    try {
      if (backupType === 'full') {
        // –ü–æ–≤–Ω–µ —Ä–µ–∑–µ—Ä–≤–Ω–µ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è - –∫–æ–ø—ñ—é–≤–∞—Ç–∏ –≤—Å—ñ –æ–±'—î–∫—Ç–∏
        await this.performFullStorageBackup(backupId)
      } else {
        // –Ü–Ω–∫—Ä–µ–º–µ–Ω—Ç–∞–ª—å–Ω–µ —Ä–µ–∑–µ—Ä–≤–Ω–µ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è - –∫–æ–ø—ñ—é–≤–∞—Ç–∏ –∑–º—ñ–Ω–µ–Ω—ñ –æ–±'—î–∫—Ç–∏
        await this.performIncrementalStorageBackup(backupId)
      }

      // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Ü—ñ–ª—ñ—Å–Ω—ñ—Å—Ç—å —Ä–µ–∑–µ—Ä–≤–Ω–æ—ó –∫–æ–ø—ñ—ó
      await this.validateStorageBackup(backupId)

      // –û–Ω–æ–≤–∏—Ç–∏ –º–µ—Ç–∞–¥–∞–Ω—ñ —Ä–µ–∑–µ—Ä–≤–Ω–æ—ó –∫–æ–ø—ñ—ó
      await this.updateStorageBackupMetadata(backupId, {
        type: backupType,
        startTime,
        endTime: new Date(),
        status: 'completed',
        objectCount: await this.getBackupObjectCount(backupId),
        totalSize: await this.getBackupTotalSize(backupId)
      })

      // –ó–∞–ø—É—Å—Ç–∏—Ç–∏ —Ä–µ–ø–ª—ñ–∫–∞—Ü—ñ—é –¥–æ —Ä–µ–∑–µ—Ä–≤–Ω–∏—Ö —Ä–µ–≥—ñ–æ–Ω—ñ–≤
      await this.replicateBackupToRegions(backupId)

      return {
        backupId,
        type: backupType,
        status: 'completed',
        duration: Date.now() - startTime.getTime()
      }

    } catch (error) {
      await this.handleStorageBackupFailure(backupId, error)
      throw error
    }
  }

  async restoreFromStorageBackup(backupId: string, targetPaths?: string[]): Promise<StorageRestoreResult> {
    const restoreId = generateStorageRestoreId()
    const startTime = new Date()

    try {
      // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —á–∏ —ñ—Å–Ω—É—î —Ä–µ–∑–µ—Ä–≤–Ω–∞ –∫–æ–ø—ñ—è —Ç–∞ —á–∏ –¥–æ—Å—Ç—É–ø–Ω–∞ –≤–æ–Ω–∞
      await this.validateBackupForRestore(backupId)

      // –í–∏–∑–Ω–∞—á–∏—Ç–∏ –æ–±'—î–∫—Ç–∏ –¥–ª—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
      const objectsToRestore = await this.getObjectsToRestore(backupId, targetPaths)

      // –í–∏–∫–æ–Ω–∞—Ç–∏ –æ–ø–µ—Ä–∞—Ü—ñ—é –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
      const restoreResult = await this.performStorageRestore(backupId, objectsToRestore)

      // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —É—Å–ø—ñ—à–Ω—ñ—Å—Ç—å –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
      await this.validateStorageRestore(restoreResult)

      // –û–Ω–æ–≤–∏—Ç–∏ –º–µ—Ç–∞–¥–∞–Ω—ñ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
      await this.updateStorageRestoreMetadata(restoreId, {
        backupId,
        targetPaths,
        startTime,
        endTime: new Date(),
        status: 'completed',
        objectsRestored: restoreResult.objectsRestored,
        totalSize: restoreResult.totalSize
      })

      return {
        restoreId,
        status: 'completed',
        objectsRestored: restoreResult.objectsRestored,
        totalSize: restoreResult.totalSize,
        duration: Date.now() - startTime.getTime()
      }

    } catch (error) {
      await this.handleStorageRestoreFailure(restoreId, error)
      throw error
    }
  }

  private async setupLifecyclePolicies(): Promise<void> {
    const lifecycleRules = [
      // –ü–µ—Ä–µ–º—ñ—Å—Ç–∏—Ç–∏ –æ–±'—î–∫—Ç–∏ –¥–æ IA —á–µ—Ä–µ–∑ 30 –¥–Ω—ñ–≤
      {
        action: { type: 'SetStorageClass', storageClass: 'STANDARD_IA' },
        condition: { age: 30 }
      },
      // –ü–µ—Ä–µ–º—ñ—Å—Ç–∏—Ç–∏ –¥–æ Archive —á–µ—Ä–µ–∑ 365 –¥–Ω—ñ–≤
      {
        action: { type: 'SetStorageClass', storageClass: 'ARCHIVE' },
        condition: { age: 365 }
      },
      // –í–∏–¥–∞–ª–∏—Ç–∏ —á–µ—Ä–µ–∑ 10 —Ä–æ–∫—ñ–≤
      {
        action: { type: 'Delete' },
        condition: { age: 3650 }
      }
    ]

    await this.storage.bucket(this.backupConfig.buckets.primary).setMetadata({
      lifecycle: { rule: lifecycleRules }
    })
  }

  private async performIncrementalStorageBackup(backupId: string): Promise<void> {
    const lastBackupTime = await this.getLastBackupTime()

    // –ü–µ—Ä–µ–ª—ñ—á–∏—Ç–∏ –æ–±'—î–∫—Ç–∏, –∑–º—ñ–Ω–µ–Ω—ñ –ø—ñ—Å–ª—è –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è
    const [files] = await this.storage.bucket(this.backupConfig.buckets.primary).getFiles({
      versions: true
    })

    const changedFiles = files.filter(file =>
      file.metadata.updated > lastBackupTime
    )

    // –°–∫–æ–ø—ñ—é–≤–∞—Ç–∏ –∑–º—ñ–Ω–µ–Ω—ñ —Ñ–∞–π–ª–∏ –¥–æ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –±–∞–∫–µ—Ç—É
    const copyPromises = changedFiles.map(file =>
      file.copy(this.storage.bucket(this.backupConfig.buckets.backup).file(
        `backup-${backupId}/${file.name}`
      ))
    )

    await Promise.all(copyPromises)
  }

  private async validateStorageBackup(backupId: string): Promise<void> {
    // –ü–µ—Ä–µ–ª—ñ—á–∏—Ç–∏ –æ–±'—î–∫—Ç–∏ —Ä–µ–∑–µ—Ä–≤–Ω–æ—ó –∫–æ–ø—ñ—ó
    const [backupFiles] = await this.storage.bucket(this.backupConfig.buckets.backup).getFiles({
      prefix: `backup-${backupId}/`
    })

    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –º–µ—Ç—Ä–∏–∫–∏ —Ä–µ–∑–µ—Ä–≤–Ω–æ—ó –∫–æ–ø—ñ—ó
    await this.validateBackupMetrics(backupFiles)

    // –í–∏–∫–æ–Ω–∞—Ç–∏ –≤–∏–±—ñ—Ä–∫–æ–≤—ñ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –Ω–∞ –≤–∏–ø–∞–¥–∫–æ–≤–∏—Ö —Ñ–∞–π–ª–∞—Ö
    await this.performSpotChecks(backupFiles)

    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è
    await this.verifyBackupEncryption(backupFiles)
  }
}`}
</Code>

## üö® –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—ñ—Å–ª—è –∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ

### –°–∏—Å—Ç–µ–º–∞ –±–∞–≥–∞—Ç–æ—Ä√©g—ñ–æ–Ω–∞–ª—å–Ω–æ–≥–æ failover

**–ê–≤—Ç–æ–º–∞—Ç–∏–∑–æ–≤–∞–Ω–∏–π failover** –∑ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥–æ–º —Å—Ç–∞–Ω—É, –ø–µ—Ä–µ–º–∏–∫–∞–Ω–Ω—è–º —Ç—Ä–∞—Ñ—ñ–∫—É —Ç–∞ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—î—é –¥–∞–Ω–∏—Ö.

// –°–∏—Å—Ç–µ–º–∞ failover –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—ñ—Å–ª—è –∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ

<Code language="typescript" title="TypeScript">
{`export class DisasterRecoveryManager {
  private regions = {
    primary: 'eu-central-1',
    secondary: 'us-east-1',
    tertiary: 'ap-southeast-1'
  }

  private failoverConfig = {
    healthChecks: {
      interval: '30 seconds',
      timeout: '10 seconds',
      unhealthyThreshold: 3,
      healthyThreshold: 2
    },
    dns: {
      ttl: 60,
      failoverTime: '5 minutes'
    },
    database: {
      syncLagThreshold: '30 seconds',
      failoverTimeout: '10 minutes'
    },
    monitoring: {
      alertChannels: ['email', 'slack', 'pagerduty'],
      escalationTime: '15 minutes'
    }
  }

  async monitorSystemHealth(): Promise<void> {
    // –ë–µ–∑–ø–µ—Ä–µ—Ä–≤–Ω–∏–π –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ –≤—Å—ñ—Ö —Ä–µ–≥—ñ–æ–Ω—ñ–≤
    setInterval(async () => {
      const healthStatus = await this.checkAllRegionsHealth()

      // –û–Ω–æ–≤–∏—Ç–∏ –≥–ª–æ–±–∞–ª—å–Ω–∏–π —Å—Ç–∞—Ç—É—Å —Å—Ç–∞–Ω—É
      await this.updateGlobalHealthStatus(healthStatus)

      // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —É–º–æ–≤–∏ failover
      const failoverRequired = this.checkFailoverConditions(healthStatus)

      if (failoverRequired) {
        await this.initiateFailover(healthStatus)
      }
    }, parseDuration(this.failoverConfig.healthChecks.interval))
  }

  async initiateFailover(healthStatus: HealthStatus): Promise<FailoverResult> {
    const failoverId = generateFailoverId()
    const startTime = new Date()

    try {
      // –í–∏–∑–Ω–∞—á–∏—Ç–∏ –Ω–∞–π–∫—Ä–∞—â—É —Ü—ñ–ª—å failover
      const targetRegion = await this.selectFailoverTarget(healthStatus)

      // –ü–æ–ø–µ—Ä–µ–¥–Ω—ñ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏
      await this.performFailoverPreflightChecks(targetRegion)

      // –ü–æ—á–∞—Ç–∏ –ø—Ä–æ—Ü–µ—Å failover
      await this.startFailoverProcess(failoverId, targetRegion)

      // –ü–µ—Ä–µ–º–∫–Ω—É—Ç–∏ DNS —â–æ–± –≤–∫–∞–∑—É–≤–∞—Ç–∏ –Ω–∞ –Ω–æ–≤–∏–π —Ä–µ–≥—ñ–æ–Ω
      await this.switchDNS(targetRegion)

      // –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–∏—Ç–∏ —Ç—Ä–∞—Ñ—ñ–∫ –¥–æ–¥–∞—Ç–∫—É
      await this.redirectApplicationTraffic(targetRegion)

      // Failover –∑'—î–¥–Ω–∞–Ω—å –±–∞–∑–∏ –¥–∞–Ω–∏—Ö
      await this.failoverDatabaseConnections(targetRegion)

      // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —É—Å–ø—ñ—à–Ω—ñ—Å—Ç—å failover
      await this.validateFailoverSuccess(targetRegion)

      // –û–Ω–æ–≤–∏—Ç–∏ –º–µ—Ç–∞–¥–∞–Ω—ñ failover
      await this.updateFailoverMetadata(failoverId, {
        startTime,
        endTime: new Date(),
        fromRegion: healthStatus.primaryRegion,
        toRegion: targetRegion,
        status: 'completed',
        duration: Date.now() - startTime.getTime()
      })

      // –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è
      await this.sendFailoverNotifications(failoverId, 'success')

      return {
        failoverId,
        status: 'completed',
        fromRegion: healthStatus.primaryRegion,
        toRegion: targetRegion,
        duration: Date.now() - startTime.getTime()
      }

    } catch (error) {
      await this.handleFailoverFailure(failoverId, error)
      throw error
    }
  }

  private async checkAllRegionsHealth(): Promise<HealthStatus> {
    const regionChecks = await Promise.allSettled(
      Object.values(this.regions).map(region =>
        this.checkRegionHealth(region)
      )
    )

    const healthStatus = {
      timestamp: new Date(),
      regions: {} as Record<string, RegionHealth>,
      primaryRegion: this.regions.primary,
      overallHealth: 'healthy' as HealthStatusType
    }

    // –û–±—Ä–æ–±–∏—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ —Ä–µ–≥—ñ–æ–Ω—ñ–≤
    regionChecks.forEach((result, index) => {
      const region = Object.values(this.regions)[index]

      if (result.status === 'fulfilled') {
        healthStatus.regions[region] = result.value
      } else {
        healthStatus.regions[region] = {
          status: 'unhealthy',
          lastChecked: new Date(),
          error: result.reason.message,
          services: {}
        }
      }
    })

    // –í–∏–∑–Ω–∞—á–∏—Ç–∏ –∑–∞–≥–∞–ª—å–Ω–∏–π —Å—Ç–∞–Ω
    healthStatus.overallHealth = this.determineOverallHealth(healthStatus.regions)

    return healthStatus
  }

  private async checkRegionHealth(region: string): Promise<RegionHealth> {
    const services = {
      database: await this.checkDatabaseHealth(region),
      application: await this.checkApplicationHealth(region),
      storage: await this.checkStorageHealth(region),
      cdn: await this.checkCDNHealth(region)
    }

    const healthyServices = Object.values(services).filter(s => s.status === 'healthy').length
    const totalServices = Object.keys(services).length

    return {
      region,
      status: healthyServices === totalServices ? 'healthy' : 'degraded',
      lastChecked: new Date(),
      services,
      healthScore: healthyServices / totalServices
    }
  }

  private checkFailoverConditions(healthStatus: HealthStatus): boolean {
    // –ü–µ—Ä–≤–∏–Ω–Ω–∏–π —Ä–µ–≥—ñ–æ–Ω –ø–æ–≤–Ω—ñ—Å—Ç—é –Ω–µ –ø—Ä–∞—Ü—é—î
    if (healthStatus.regions[healthStatus.primaryRegion].status === 'unhealthy') {
      return true
    }

    // –ü–µ—Ä–≤–∏–Ω–Ω–∏–π —Ä–µ–≥—ñ–æ–Ω –ø–æ–≥—ñ—Ä—à–µ–Ω–∏–π —ñ –≤—Ç–æ—Ä–∏–Ω–Ω–∏–π –∑–¥–æ—Ä–æ–≤–∏–π
    const primaryHealth = healthStatus.regions[healthStatus.primaryRegion]
    const secondaryHealth = healthStatus.regions[this.regions.secondary]

    if (primaryHealth.status === 'degraded' &&
        primaryHealth.healthScore < 0.5 &&
        secondaryHealth.status === 'healthy') {
      return true
    }

    // –†—É—á–Ω–∏–π failover –∑–∞–ø—É—â–µ–Ω–∏–π
    return this.manualFailoverTriggered()
  }

  private async selectFailoverTarget(healthStatus: HealthStatus): Promise<string> {
    // –£–ø–æ—Ä—è–¥–∫—É–≤–∞—Ç–∏ —Ä–µ–≥—ñ–æ–Ω–∏ –∑–∞ –±–∞–ª–æ–º —Å—Ç–∞–Ω—É
    const sortedRegions = Object.entries(healthStatus.regions)
      .filter(([_, health]) => health.status === 'healthy')
      .sort((a, b) => b[1].healthScore - a[1].healthScore)

    if (sortedRegions.length === 0) {
      throw new Error('–ù–µ–º–∞—î –∑–¥–æ—Ä–æ–≤–∏—Ö —Ä–µ–≥—ñ–æ–Ω—ñ–≤ –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –¥–ª—è failover')
    }

    // –ü–æ–≤–µ—Ä–Ω—É—Ç–∏ –Ω–∞–π–∑–¥–æ—Ä–æ–≤—ñ—à–∏–π –¥–æ—Å—Ç—É–ø–Ω–∏–π —Ä–µ–≥—ñ–æ–Ω
    return sortedRegions[0][0]
  }

  private async switchDNS(targetRegion: string): Promise<void> {
    // –û–Ω–æ–≤–∏—Ç–∏ –∑–∞–ø–∏—Å–∏ Route 53 –∞–±–æ Cloud DNS
    const dnsClient = this.getDNSClient()

    // –û–Ω–æ–≤–∏—Ç–∏ –æ—Å–Ω–æ–≤–Ω–∏–π –¥–æ–º–µ–Ω
    await dnsClient.changeResourceRecordSets({
      hostedZoneId: process.env.HOSTED_ZONE_ID,
      changeBatch: {
        changes: [{
          action: 'UPSERT',
          resourceRecordSet: {
            name: process.env.DOMAIN_NAME,
            type: 'A',
            aliasTarget: {
              dnsName: this.getLoadBalancerDNS(targetRegion),
              hostedZoneId: this.getLoadBalancerHostedZone(targetRegion),
              evaluateTargetHealth: true
            },
            setIdentifier: `failover-${Date.now()}`,
            failover: 'PRIMARY'
          }
        }]
      }
    })
  }

  private async failoverDatabaseConnections(targetRegion: string): Promise<void> {
    // –û–Ω–æ–≤–∏—Ç–∏ —Ä—è–¥–∫–∏ –∑'—î–¥–Ω–∞–Ω–Ω—è –∑ –±–∞–∑–æ—é –¥–∞–Ω–∏—Ö
    await this.updateApplicationConfig({
      database: {
        host: this.getDatabaseEndpoint(targetRegion),
        region: targetRegion
      }
    })

    // –ó–∞–ø—É—Å—Ç–∏—Ç–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Ñ–ª–æ—Ç—É –¥–æ–¥–∞—Ç–∫—ñ–≤ —â–æ–± –ø—ñ–¥—ñ–±—Ä–∞—Ç–∏ –Ω–æ–≤—É –∫–æ–Ω—Ñ—ñ–≥
    await this.restartApplicationFleet()

    // –ó–∞—á–µ–∫–∞—Ç–∏ –ø–æ–∫–∏ –∑'—î–¥–Ω–∞–Ω–Ω—è –≤–∏—Ç—ñ–∫–∞—Ç–∏–º—É—Ç—å –∑—ñ —Å—Ç–∞—Ä–æ–≥–æ —Ä–µ–≥—ñ–æ–Ω—É
    await this.waitForConnectionDrain()

    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –∑'—î–¥–Ω–∞–Ω–Ω—è –∑ –±–∞–∑–æ—é –¥–∞–Ω–∏—Ö —É –Ω–æ–≤–æ–º—É —Ä–µ–≥—ñ–æ–Ω—ñ
    await this.validateDatabaseConnectivity(targetRegion)
  }
}`}
</Code>

### –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–æ —Ç–æ—á–∫–∏ –≤ —á–∞—Å—ñ

**–ì—Ä–∞–Ω—É–ª—è—Ä–Ω–µ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö** –∑ –≤—ñ–¥—Ç–≤–æ—Ä–µ–Ω–Ω—è–º –∂—É—Ä–Ω–∞–ª—É —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ–π —Ç–∞ —Å–µ–ª–µ–∫—Ç–∏–≤–Ω–∏–º –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è–º.

// –°–∏—Å—Ç–µ–º–∞ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–æ —Ç–æ—á–∫–∏ –≤ —á–∞—Å—ñ

<Code language="typescript" title="TypeScript">
{`export class PointInTimeRecovery {
  private recoveryConfig = {
    maxRecoveryWindow: '30 days',
    granularity: '1 second',
    parallelWorkers: 4,
    validation: {
      enabled: true,
      sampleRate: 0.1 // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ 10% –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–∏—Ö –¥–∞–Ω–∏—Ö
    }
  }

  async performPointInTimeRecovery(
    targetTime: Date,
    targetDatabase: string,
    options: RecoveryOptions = {}
  ): Promise<RecoveryResult> {
    const recoveryId = generateRecoveryId()
    const startTime = new Date()

    try {
      // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
      await this.validateRecoveryParameters(targetTime, targetDatabase)

      // –°—Ç–≤–æ—Ä–∏—Ç–∏ —Ç–∏–º—á–∞—Å–æ–≤–∏–π —ñ–Ω—Å—Ç–∞–Ω—Å –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
      const tempInstance = await this.createTemporaryInstance()

      // –í—ñ–¥–Ω–æ–≤–∏—Ç–∏ –±–∞–∑–æ–≤—É —Ä–µ–∑–µ—Ä–≤–Ω—É –∫–æ–ø—ñ—é
      const baseBackup = await this.findBaseBackup(targetTime)
      await this.restoreBaseBackup(baseBackup, tempInstance)

      // –ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –∂—É—Ä–Ω–∞–ª–∏ WAL –¥–æ —Ü—ñ–ª—å–æ–≤–æ–≥–æ —á–∞—Å—É
      await this.applyWalLogs(tempInstance, baseBackup.timestamp, targetTime)

      // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Å—Ç–∞–Ω –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
      await this.validateRecoveryState(tempInstance, targetTime)

      // –ï–∫—Å–ø–æ—Ä—Ç—É–≤–∞—Ç–∏ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω—ñ –¥–∞–Ω—ñ
      const exportPath = await this.exportRecoveredData(tempInstance, options)

      // –Ü–º–ø–æ—Ä—Ç—É–≤–∞—Ç–∏ –¥–æ —Ü—ñ–ª—å–æ–≤–æ—ó –±–∞–∑–∏ –¥–∞–Ω–∏—Ö (—è–∫—â–æ –≤–∫–∞–∑–∞–Ω–æ)
      if (options.targetDatabase) {
        await this.importToTargetDatabase(exportPath, options.targetDatabase, options)
      }

      // –û—á–∏—Å—Ç–∏—Ç–∏ —Ç–∏–º—á–∞—Å–æ–≤–∏–π —ñ–Ω—Å—Ç–∞–Ω—Å
      await this.cleanupTemporaryInstance(tempInstance)

      // –û–Ω–æ–≤–∏—Ç–∏ –º–µ—Ç–∞–¥–∞–Ω—ñ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
      await this.updateRecoveryMetadata(recoveryId, {
        targetTime,
        baseBackup: baseBackup.id,
        startTime,
        endTime: new Date(),
        status: 'completed',
        exportedPath: exportPath,
        targetDatabase: options.targetDatabase
      })

      return {
        recoveryId,
        status: 'completed',
        targetTime,
        recoveredTo: options.targetDatabase || exportPath,
        duration: Date.now() - startTime.getTime()
      }

    } catch (error) {
      await this.handleRecoveryFailure(recoveryId, error)
      throw error
    }
  }

  async performSelectiveRecovery(
    targetTime: Date,
    tables: string[],
    conditions: RecoveryConditions,
    targetDatabase: string
  ): Promise<SelectiveRecoveryResult> {
    const recoveryId = generateSelectiveRecoveryId()
    const startTime = new Date()

    try {
      // –°—Ç–≤–æ—Ä–∏—Ç–∏ —Ç–∏–º—á–∞—Å–æ–≤–∏–π —ñ–Ω—Å—Ç–∞–Ω—Å –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
      const tempInstance = await this.createTemporaryInstance()

      // –í–∏–∫–æ–Ω–∞—Ç–∏ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–æ —Ç–æ—á–∫–∏ –≤ —á–∞—Å—ñ
      await this.performPointInTimeRecovery(targetTime, tempInstance.id)

      // –í–∏—Ç—è–≥—Ç–∏ —Å–µ–ª–µ–∫—Ç–∏–≤–Ω—ñ –¥–∞–Ω—ñ
      const extractedData = await this.extractSelectiveData(
        tempInstance,
        tables,
        conditions
      )

      // –ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—ó —è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ
      const transformedData = await this.applyDataTransformations(
        extractedData,
        conditions.transformations
      )

      // –Ü–º–ø–æ—Ä—Ç—É–≤–∞—Ç–∏ –¥–æ —Ü—ñ–ª—å–æ–≤–æ—ó –±–∞–∑–∏ –¥–∞–Ω–∏—Ö
      await this.importSelectiveData(transformedData, targetDatabase)

      // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Å–µ–ª–µ–∫—Ç–∏–≤–Ω–µ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
      await this.validateSelectiveRecovery(transformedData, targetDatabase)

      // –û—á–∏—Å—Ç–∏—Ç–∏
      await this.cleanupTemporaryInstance(tempInstance)

      // –û–Ω–æ–≤–∏—Ç–∏ –º–µ—Ç–∞–¥–∞–Ω—ñ
      await this.updateSelectiveRecoveryMetadata(recoveryId, {
        targetTime,
        tables,
        conditions,
        targetDatabase,
        startTime,
        endTime: new Date(),
        status: 'completed',
        recordsRecovered: transformedData.totalRecords
      })

      return {
        recoveryId,
        status: 'completed',
        targetTime,
        tables,
        recordsRecovered: transformedData.totalRecords,
        targetDatabase,
        duration: Date.now() - startTime.getTime()
      }

    } catch (error) {
      await this.handleSelectiveRecoveryFailure(recoveryId, error)
      throw error
    }
  }

  private async findBaseBackup(targetTime: Date): Promise<BackupInfo> {
    // –ó–Ω–∞–π—Ç–∏ –Ω–∞–π–æ—Å—Ç–∞–Ω–Ω—ñ—à—É –ø–æ–≤–Ω—É —Ä–µ–∑–µ—Ä–≤–Ω—É –∫–æ–ø—ñ—é –ø–µ—Ä–µ–¥ —Ü—ñ–ª—å–æ–≤–∏–º —á–∞—Å–æ–º
    const baseBackup = await this.queryBackups({
      type: 'full',
      beforeTime: targetTime,
      orderBy: 'timestamp DESC',
      limit: 1
    })

    if (!baseBackup) {
      throw new Error(`–ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ –ø—Ä–∏–¥–∞—Ç–Ω–æ—ó –±–∞–∑–æ–≤–æ—ó —Ä–µ–∑–µ—Ä–≤–Ω–æ—ó –∫–æ–ø—ñ—ó –¥–ª—è —á–∞—Å—É ${targetTime}`)
    }

    return baseBackup
  }

  private async applyWalLogs(
    instance: TempInstance,
    fromTime: Date,
    toTime: Date
  ): Promise<void> {
    // –ó–Ω–∞–π—Ç–∏ —Ñ–∞–π–ª–∏ WAL –º—ñ–∂ fromTime —Ç–∞ toTime
    const walFiles = await this.findWalFilesInRange(fromTime, toTime)

    // –ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ —Ñ–∞–π–ª–∏ WAL –ø–∞—Ä–∞–ª–µ–ª—å–Ω–æ
    const workers = Math.min(this.recoveryConfig.parallelWorkers, walFiles.length)
    const chunks = this.chunkArray(walFiles, workers)

    const applyPromises = chunks.map(async (chunk, workerId) => {
      for (const walFile of chunk) {
        await this.applyWalFile(instance, walFile, workerId)
      }
    })

    await Promise.all(applyPromises)
  }

  private async validateRecoveryState(instance: TempInstance, targetTime: Date): Promise<void> {
    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å –±–∞–∑–∏ –¥–∞–Ω–∏—Ö
    await this.checkDatabaseConsistency(instance)

    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Ç–æ—á–Ω—ñ—Å—Ç—å —Ü—ñ–ª—å–æ–≤–æ–≥–æ —á–∞—Å—É
    const actualTime = await this.getDatabaseTime(instance)
    const timeDifference = Math.abs(actualTime.getTime() - targetTime.getTime())

    if (timeDifference > 5000) { // 5 —Å–µ–∫—É–Ω–¥–Ω–∞ —Ç–æ–ª–µ—Ä–∞–Ω—Ç–Ω—ñ—Å—Ç—å
      throw new Error(`–ü–æ–º–∏–ª–∫–∞ —Ç–æ—á–Ω–æ—Å—Ç—ñ —á–∞—Å—É –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è: ${timeDifference}–º—Å —Ä—ñ–∑–Ω–∏—Ü—ñ`)
    }

    // –í–∏–±—ñ—Ä–∫–æ–≤–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—è —è–∫—â–æ —É–≤—ñ–º–∫–Ω–µ–Ω–æ
    if (this.recoveryConfig.validation.enabled) {
      await this.performSampleValidation(instance, targetTime)
    }
  }

  private async extractSelectiveData(
    instance: TempInstance,
    tables: string[],
    conditions: RecoveryConditions
  ): Promise<ExtractedData> {
    const extractedData: ExtractedData = {
      tables: {},
      totalRecords: 0
    }

    for (const table of tables) {
      const query = this.buildSelectiveQuery(table, conditions)
      const data = await this.executeQueryOnInstance(instance, query)

      extractedData.tables[table] = data
      extractedData.totalRecords += data.length
    }

    return extractedData
  }
}`}
</Code>

## üîÑ –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è —Ç–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è

### –ê–≤—Ç–æ–º–∞—Ç–∏–∑–æ–≤–∞–Ω—ñ —Ç—Ä–µ–Ω—É–≤–∞–Ω–Ω—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è

**–†–µ–≥—É–ª—è—Ä–Ω–µ —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è** —Ü—ñ–ª—ñ—Å–Ω–æ—Å—Ç—ñ —Ä–µ–∑–µ—Ä–≤–Ω–∏—Ö –∫–æ–ø—ñ–π, –ø—Ä–æ—Ü–µ–¥—É—Ä –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è —Ç–∞ —Å—Ç—ñ–π–∫–æ—Å—Ç—ñ —Å–∏—Å—Ç–µ–º–∏.

// –°–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–æ–≤–∞–Ω–æ–≥–æ —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è

<Code language="typescript" title="TypeScript">
{`export class RecoveryTestingManager {
  private testConfig = {
    schedules: {
      daily: '0 3 * * *',      // –©–æ–¥–Ω—è –æ 3:00
      weekly: '0 4 * * 0',     // –©–æ—Ç–∏–∂–Ω—è –Ω–µ–¥—ñ–ª—è –æ 4:00
      monthly: '0 5 1 * *'     // –©–æ–º—ñ—Å—è—Ü—è 1-–≥–æ –æ 5:00
    },
    testTypes: {
      integrity: { frequency: 'daily', duration: '30 minutes' },
      performance: { frequency: 'weekly', duration: '2 hours' },
      fullRecovery: { frequency: 'monthly', duration: '4 hours' }
    },
    validation: {
      dataIntegrity: true,
      performanceMetrics: true,
      functionalityTests: true
    }
  }

  async scheduleRecoveryTests(): Promise<void> {
    // –ó–∞–ø–ª–∞–Ω—É–≤–∞—Ç–∏ —Ç–µ—Å—Ç–∏ —Ü—ñ–ª—ñ—Å–Ω–æ—Å—Ç—ñ
    await this.scheduleTestType('integrity')

    // –ó–∞–ø–ª–∞–Ω—É–≤–∞—Ç–∏ —Ç–µ—Å—Ç–∏ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ
    await this.scheduleTestType('performance')

    // –ó–∞–ø–ª–∞–Ω—É–≤–∞—Ç–∏ –ø–æ–≤–Ω—ñ —Ç–µ—Å—Ç–∏ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
    await this.scheduleTestType('fullRecovery')

    // –ù–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ —Ç–µ—Å—Ç—ñ–≤
    await this.setupTestMonitoring()

    // –ù–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è —Ç–µ—Å—Ç—ñ–≤
    await this.setupTestNotifications()
  }

  async runRecoveryTest(testType: TestType): Promise<TestResult> {
    const testId = generateTestId()
    const startTime = new Date()

    try {
      // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ —Ç–µ—Å—Ç–æ–≤–µ —Å–µ—Ä–µ–¥–æ–≤–∏—â–µ
      const testEnv = await this.initializeTestEnvironment(testType)

      // –í–∏–∫–æ–Ω–∞—Ç–∏ —Ç–µ—Å—Ç –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ —Ç–∏–ø—É
      let testResult: TestResult

      switch (testType) {
        case 'integrity':
          testResult = await this.runIntegrityTest(testEnv)
          break
        case 'performance':
          testResult = await this.runPerformanceTest(testEnv)
          break
        case 'fullRecovery':
          testResult = await this.runFullRecoveryTest(testEnv)
          break
      }

      // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ —Ç–µ—Å—Ç—ñ–≤
      await this.validateTestResults(testResult)

      // –û–Ω–æ–≤–∏—Ç–∏ –º–µ—Ç–∞–¥–∞–Ω—ñ —Ç–µ—Å—Ç—ñ–≤
      await this.updateTestMetadata(testId, {
        type: testType,
        startTime,
        endTime: new Date(),
        status: 'completed',
        result: testResult,
        environment: testEnv
      })

      // –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è —Ç–µ—Å—Ç—ñ–≤
      await this.sendTestNotifications(testId, 'success', testResult)

      return {
        testId,
        type: testType,
        status: 'completed',
        result: testResult,
        duration: Date.now() - startTime.getTime()
      }

    } catch (error) {
      await this.handleTestFailure(testId, error)
      throw error
    }
  }

  private async runIntegrityTest(testEnv: TestEnvironment): Promise<IntegrityTestResult> {
    // –¢–µ—Å—Ç—É–≤–∞—Ç–∏ —Ü—ñ–ª—ñ—Å–Ω—ñ—Å—Ç—å —Ä–µ–∑–µ—Ä–≤–Ω–∏—Ö –∫–æ–ø—ñ–π
    const backupIntegrity = await this.testBackupIntegrity(testEnv)

    // –¢–µ—Å—Ç—É–≤–∞—Ç–∏ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å –¥–∞–Ω–∏—Ö
    const dataConsistency = await this.testDataConsistency(testEnv)

    // –¢–µ—Å—Ç—É–≤–∞—Ç–∏ –≤–∞–ª—ñ–¥–∞—Ü—ñ—é —à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è
    const encryptionValidation = await this.testEncryptionValidation(testEnv)

    // –†–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏ –∑–∞–≥–∞–ª—å–Ω–∏–π –±–∞–ª —Ü—ñ–ª—ñ—Å–Ω–æ—Å—Ç—ñ
    const overallScore = this.calculateIntegrityScore({
      backupIntegrity,
      dataConsistency,
      encryptionValidation
    })

    return {
      backupIntegrity,
      dataConsistency,
      encryptionValidation,
      overallScore,
      passed: overallScore >= 0.95 // 95% –ø–æ—Ä—ñ–≥
    }
  }

  private async runPerformanceTest(testEnv: TestEnvironment): Promise<PerformanceTestResult> {
    // –¢–µ—Å—Ç—É–≤–∞—Ç–∏ —Ü—ñ–ª—ñ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è —á–∞—Å—É
    const rtoResults = await this.testRecoveryTimeObjectives(testEnv)

    // –¢–µ—Å—Ç—É–≤–∞—Ç–∏ —Ü—ñ–ª—ñ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è —Ç–æ—á–∫–∏
    const rpoResults = await this.testRecoveryPointObjectives(testEnv)

    // –¢–µ—Å—Ç—É–≤–∞—Ç–∏ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å —Å–∏—Å—Ç–µ–º–∏ –ø—ñ–¥ —á–∞—Å –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
    const performanceMetrics = await this.testSystemPerformance(testEnv)

    return {
      rtoResults,
      rpoResults,
      performanceMetrics,
      passed: this.validatePerformanceResults(rtoResults, rpoResults, performanceMetrics)
    }
  }

  private async runFullRecoveryTest(testEnv: TestEnvironment): Promise<FullRecoveryTestResult> {
    // –í–∏–∫–æ–Ω–∞—Ç–∏ –ø–æ–≤–Ω–µ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è —Å–∏—Å—Ç–µ–º–∏
    const recoveryResult = await this.performCompleteRecovery(testEnv)

    // –¢–µ—Å—Ç—É–≤–∞—Ç–∏ —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω—ñ—Å—Ç—å —Å–∏—Å—Ç–µ–º–∏ –ø—ñ—Å–ª—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
    const functionalityTests = await this.testPostRecoveryFunctionality(testEnv)

    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Ü—ñ–ª—ñ—Å–Ω—ñ—Å—Ç—å –¥–∞–Ω–∏—Ö
    const dataValidation = await this.validateRecoveredData(testEnv)

    return {
      recoveryResult,
      functionalityTests,
      dataValidation,
      passed: recoveryResult.success && functionalityTests.passed && dataValidation.passed
    }
  }

  private async testBackupIntegrity(testEnv: TestEnvironment): Promise<BackupIntegrityResult> {
    const results = []

    // –¢–µ—Å—Ç—É–≤–∞—Ç–∏ –∫–æ–∂–µ–Ω —Ç–∏–ø —Ä–µ–∑–µ—Ä–≤–Ω–æ—ó –∫–æ–ø—ñ—ó
    for (const backup of testEnv.backups) {
      try {
        // –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –≤—ñ–¥–Ω–æ–≤–∏—Ç–∏ —Ä–µ–∑–µ—Ä–≤–Ω—É –∫–æ–ø—ñ—é
        const restoreResult = await this.testBackupRestore(backup)

        // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω—ñ –¥–∞–Ω—ñ
        const validationResult = await this.validateRestoredData(restoreResult)

        results.push({
          backupId: backup.id,
          type: backup.type,
          restoredSuccessfully: true,
          dataValid: validationResult.valid,
          restoreTime: restoreResult.duration,
          dataSize: restoreResult.size
        })
      } catch (error) {
        results.push({
          backupId: backup.id,
          type: backup.type,
          restoredSuccessfully: false,
          error: error.message
        })
      }
    }

    const successRate = results.filter(r => r.restoredSuccessfully && r.dataValid).length / results.length

    return {
      results,
      successRate,
      averageRestoreTime: this.calculateAverageRestoreTime(results),
      totalDataValidated: this.calculateTotalDataSize(results)
    }
  }

  private async validateTestResults(result: TestResult): Promise<void> {
    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —á–∏ —Ç–µ—Å—Ç –ø—Ä–æ–π—à–æ–≤ –º—ñ–Ω—ñ–º–∞–ª—å–Ω—ñ –ø–æ—Ä–æ–≥–∏
    if (!result.passed) {
      throw new Error(`–¢–µ—Å—Ç –Ω–µ –ø—Ä–æ–π—à–æ–≤: ${result.type} —Ç–µ—Å—Ç –Ω–µ –∑–∞–¥–æ–≤–æ–ª—å–Ω–∏–≤ –º—ñ–Ω—ñ–º–∞–ª—å–Ω—ñ –≤–∏–º–æ–≥–∏`)
    }

    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –æ—á–∏—â–µ–Ω–Ω—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Å–µ—Ä–µ–¥–æ–≤–∏—â–∞
    await this.validateTestEnvironmentCleanup(result)

    // –ó–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –∑–≤—ñ—Ç —Ç–µ—Å—Ç—ñ–≤
    await this.generateTestReport(result)
  }
}`}
</Code>

## üìä –ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ —Ç–∞ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è

### –ü–∞–Ω–µ–ª—å —Å—Ç–∞–Ω—É —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è

**–ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ –≤ —Ä–µ–∂–∏–º—ñ —Ä–µ–∞–ª—å–Ω–æ–≥–æ —á–∞—Å—É** —Å—Ç–∞—Ç—É—Å—É —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è, —Ü—ñ–ª—ñ—Å–Ω–æ—Å—Ç—ñ —Ç–∞ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—ñ –¥–æ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è.

// –°–∏—Å—Ç–µ–º–∞ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É —Ç–∞ —Å–ø–æ–≤—ñ—â–µ–Ω—å —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è

<Code language="typescript" title="TypeScript">
{`export class BackupMonitoringSystem {
  private monitoringConfig = {
    metrics: {
      collectionInterval: '5 minutes',
      retentionPeriod: '90 days',
      alerting: {
        backupFailure: { threshold: 1, severity: 'critical' },
        backupDelay: { threshold: '2 hours', severity: 'warning' },
        integrityFailure: { threshold: 1, severity: 'critical' },
        storageFull: { threshold: '85%', severity: 'warning' }
      }
    },
    dashboards: {
      backupStatus: '/monitoring/backup-status',
      recoveryReadiness: '/monitoring/recovery-readiness',
      dataIntegrity: '/monitoring/data-integrity'
    }
  }

  async monitorBackupHealth(): Promise<void> {
    // –ë–µ–∑–ø–µ—Ä–µ—Ä–≤–Ω–∏–π —Ü–∏–∫–ª –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É
    setInterval(async () => {
      try {
        // –ó—ñ–±—Ä–∞—Ç–∏ –º–µ—Ç—Ä–∏–∫–∏ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è
        const metrics = await this.collectBackupMetrics()

        // –û–Ω–æ–≤–∏—Ç–∏ –ø–∞–Ω–µ–ª—å –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É
        await this.updateMonitoringDashboard(metrics)

        // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —É–º–æ–≤–∏ —Å–ø–æ–≤—ñ—â–µ–Ω—å
        const alerts = await this.checkAlertConditions(metrics)

        // –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è —è–∫—â–æ —î
        if (alerts.length > 0) {
          await this.sendBackupAlerts(alerts)
        }

        // –û–Ω–æ–≤–∏—Ç–∏ —Å—Ç–∞—Ç—É—Å —Å—Ç–∞–Ω—É
        await this.updateBackupHealthStatus(metrics)

      } catch (error) {
        console.error('–ü–æ–º–∏–ª–∫–∞ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è:', error)
        await this.sendMonitoringErrorAlert(error)
      }
    }, parseDuration(this.monitoringConfig.metrics.collectionInterval))
  }

  private async collectBackupMetrics(): Promise<BackupMetrics> {
    return {
      timestamp: new Date(),
      database: await this.collectDatabaseBackupMetrics(),
      firestore: await this.collectFirestoreBackupMetrics(),
      storage: await this.collectStorageBackupMetrics(),
      overall: await this.calculateOverallBackupHealth()
    }
  }

  private async collectDatabaseBackupMetrics(): Promise<DatabaseBackupMetrics> {
    const latestBackup = await this.getLatestDatabaseBackup()
    const backupAge = Date.now() - latestBackup.timestamp.getTime()

    return {
      lastBackupTime: latestBackup.timestamp,
      backupAge: backupAge,
      backupSize: latestBackup.size,
      backupStatus: latestBackup.status,
      walArchivingStatus: await this.checkWalArchivingStatus(),
      replicationLag: await this.getReplicationLag(),
      integrityStatus: await this.getBackupIntegrityStatus()
    }
  }

  private async checkAlertConditions(metrics: BackupMetrics): Promise<Alert[]> {
    const alerts: Alert[] = []

    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –≤—ñ–∫—É —Ä–µ–∑–µ—Ä–≤–Ω–æ—ó –∫–æ–ø—ñ—ó
    if (metrics.database.backupAge > parseDuration('24 hours')) {
      alerts.push({
        type: 'backup_age',
        severity: 'warning',
        message: `–†–µ–∑–µ—Ä–≤–Ω–∞ –∫–æ–ø—ñ—è –±–∞–∑–∏ –¥–∞–Ω–∏—Ö —Å—Ç–∞—Ä–∞ –Ω–∞ ${Math.round(metrics.database.backupAge / (1000 * 60 * 60))} –≥–æ–¥–∏–Ω`,
        component: 'database'
      })
    }

    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è —Å—Ö–æ–≤–∏—â–∞
    if (metrics.storage.usagePercentage > 85) {
      alerts.push({
        type: 'storage_full',
        severity: 'warning',
        message: `–°—Ö–æ–≤–∏—â–µ —Ä–µ–∑–µ—Ä–≤–Ω–∏—Ö –∫–æ–ø—ñ–π –∑–∞–ø–æ–≤–Ω–µ–Ω–æ –Ω–∞ ${metrics.storage.usagePercentage}%`,
        component: 'storage'
      })
    }

    // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è —Ü—ñ–ª—ñ—Å–Ω–æ—Å—Ç—ñ
    if (!metrics.database.integrityStatus.valid) {
      alerts.push({
        type: 'integrity_failure',
        severity: 'critical',
        message: '–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ü—ñ–ª—ñ—Å–Ω–æ—Å—Ç—ñ —Ä–µ–∑–µ—Ä–≤–Ω–æ—ó –∫–æ–ø—ñ—ó –±–∞–∑–∏ –¥–∞–Ω–∏—Ö –Ω–µ –ø—Ä–æ–π—à–ª–∞',
        component: 'database'
      })
    }

    return alerts
  }

  private async sendBackupAlerts(alerts: Alert[]): Promise<void> {
    for (const alert of alerts) {
      // –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ –¥–æ –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–∏—Ö –∫–∞–Ω–∞–ª—ñ–≤
      await Promise.all([
        this.sendEmailAlert(alert),
        this.sendSlackAlert(alert),
        this.sendPagerDutyAlert(alert)
      ])

      // –ó–∞–ø–∏—Å–∞—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è
      await this.logBackupAlert(alert)
    }
  }

  async generateBackupReport(timeRange: TimeRange): Promise<BackupReport> {
    const metrics = await this.getBackupMetricsHistory(timeRange)

    return {
      timeRange,
      generatedAt: new Date(),
      summary: {
        totalBackups: metrics.length,
        successfulBackups: metrics.filter(m => m.overall.status === 'healthy').length,
        failedBackups: metrics.filter(m => m.overall.status === 'unhealthy').length,
        averageBackupSize: this.calculateAverage(metrics.map(m => m.database.backupSize)),
        averageBackupDuration: this.calculateAverage(metrics.map(m => m.database.backupDuration))
      },
      trends: this.analyzeBackupTrends(metrics),
      recommendations: this.generateBackupRecommendations(metrics)
    }
  }
}`}
</Code>

## üöÄ –ü–ª–∞–Ω —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó

### –§–∞–∑–∞ 1: –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç—É (–¢–∏–∂–Ω—ñ 1-2)
<Steps>
<Step>
**–°–ø—Ä–æ–µ–∫—Ç—É–≤–∞—Ç–∏ –∞—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä—É —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è** —Ç–∞ –ø–æ–ª—ñ—Ç–∏–∫–∏ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è
</Step>
<Step>
**–ù–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ —Å–∏—Å—Ç–µ–º–∏ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è –±–∞–∑–∏ –¥–∞–Ω–∏—Ö** –∑ pgBackRest
</Step>
<Step>
**–ù–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ –µ–∫—Å–ø–æ—Ä—Ç–∏ Firestore** —Ç–∞ —Ä–µ–∑–µ—Ä–≤–Ω–µ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è —Å—Ö–æ–≤–∏—â–∞
</Step>
</Steps>

### –§–∞–∑–∞ 2: –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü—ñ—è —Ç–∞ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ (–¢–∏–∂–Ω—ñ 3-6)
<Steps>
<Step>
**–†–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–æ–≤–∞–Ω—ñ —Ä–æ–∑–∫–ª–∞–¥–∏ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è** —Ç–∞ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥
</Step>
<Step>
**–ù–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ –∫—Ä–æ—Å-—Ä–µ–≥—ñ–æ–Ω–∞–ª—å–Ω—É —Ä–µ–ø–ª—ñ–∫–∞—Ü—ñ—é** —Ç–∞ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—ñ—Å–ª—è –∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ
</Step>
<Step>
**–°—Ç–≤–æ—Ä–∏—Ç–∏ –≤–∞–ª—ñ–¥–∞—Ü—ñ—é —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è** —Ç–∞ —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è —Ü—ñ–ª—ñ—Å–Ω–æ—Å—Ç—ñ
</Step>
</Steps>

### –§–∞–∑–∞ 3: –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è —Ç–∞ —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è (–¢–∏–∂–Ω—ñ 7-12)
<Steps>
<Step>
**–ü–æ–±—É–¥—É–≤–∞—Ç–∏ –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–æ —Ç–æ—á–∫–∏ –≤ —á–∞—Å—ñ**
</Step>
<Step>
**–†–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–æ–≤–∞–Ω—ñ —Ç—Ä–µ–Ω—É–≤–∞–Ω–Ω—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è** —Ç–∞ —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è
</Step>
<Step>
**–ù–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ –ø–∞–Ω–µ–ª—ñ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É** —Ç–∞ —Å–∏—Å—Ç–µ–º–∏ —Å–ø–æ–≤—ñ—â–µ–Ω—å
</Step>
</Steps>

### –§–∞–∑–∞ 4: –ö–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó (–¢–∏–∂–Ω—ñ 13-16)
<Steps>
<Step>
**–†–æ–∑–≥–æ—Ä–Ω—É—Ç–∏ –±–∞–≥–∞—Ç–æ—Ä√©g—ñ–æ–Ω–∞–ª—å–Ω–∏–π failover** —Ç–∞ —Ä–æ–∑—à–∏—Ä–µ–Ω–µ DR
</Step>
<Step>
**–†–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ –∑–≤—ñ—Ç–Ω—ñ—Å—Ç—å –¥–æ—Ç—Ä–∏–º–∞–Ω–Ω—è –≤–∏–º–æ–≥** —Ç–∞ –∞—É–¥–∏—Ç–æ—Ä—Å—å–∫—ñ –∂—É—Ä–Ω–∞–ª–∏
</Step>
<Step>
**–ù–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ –±–µ–∑–ø–µ—Ä–µ—Ä–≤–Ω—É –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—é** —Ç–∞ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –≤–∏—Ç—Ä–∞—Ç–∞–º–∏
</Step>
</Steps>

## üìä –ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø—ñ—Ö—É

### –¶—ñ–ª—ñ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
- **RTO (–ß–∞—Å –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è)**: 15 —Ö–≤–∏–ª–∏–Ω –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω–∏—Ö —Å–∏—Å—Ç–µ–º
- **RPO (–¢–æ—á–∫–∞ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è)**: 5 —Ö–≤–∏–ª–∏–Ω –¥–ª—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ–π–Ω–∏—Ö –¥–∞–Ω–∏—Ö
- **–¶—ñ–ª—ñ—Å–Ω—ñ—Å—Ç—å –¥–∞–Ω–∏—Ö**: 99.999999999% (11 9's)
- **–®–≤–∏–¥–∫—ñ—Å—Ç—å —É—Å–ø—ñ—à–Ω–æ—Å—Ç—ñ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è**: 99.9% –¥–ª—è –≤—Å—ñ—Ö —Å–∏—Å—Ç–µ–º

### –û–ø–µ—Ä–∞—Ü—ñ–π–Ω–∞ –¥–æ—Å–∫–æ–Ω–∞–ª—ñ—Å—Ç—å
- **99.95% –î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—ñ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è** –∑ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–æ–≤–∞–Ω–∏–º failover
- **–ù—É–ª—å —ñ–Ω—Ü–∏–¥–µ–Ω—Ç—ñ–≤ –≤—Ç—Ä–∞—Ç–∏ –¥–∞–Ω–∏—Ö** —É –≤–∏—Ä–æ–±–Ω–∏—á–æ–º—É —Å–µ—Ä–µ–¥–æ–≤–∏—â—ñ
- **100% –®–≤–∏–¥–∫–æ—Å—Ç—ñ —É—Å–ø—ñ—à–Ω–æ—Å—Ç—ñ —Ç–µ—Å—Ç—ñ–≤ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è** —â–æ–∫–≤–∞—Ä—Ç–∞–ª—å–Ω–æ
- **85% –ó–º–µ–Ω—à–µ–Ω–Ω—è –≤–∏—Ç—Ä–∞—Ç** –ø–æ—Ä—ñ–≤–Ω—è–Ω–æ –∑ —Ç—Ä–∞–¥–∏—Ü—ñ–π–Ω–∏–º–∏ —Ä—ñ—à–µ–Ω–Ω—è–º–∏ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è

---

<Callout type="info">
**–ì–æ—Ç–æ–≤—ñ –∑–∞—Ö–∏—Å—Ç–∏—Ç–∏ —Å–≤–æ—ó –¥–∞–Ω—ñ?** –ö–æ–º–ø–ª–µ–∫—Å–Ω—ñ —Å—Ç—Ä–∞—Ç–µ–≥—ñ—ó —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è —Ç–∞ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –∑–∞–±–µ–∑–ø–µ—á—É—é—Ç—å –±–µ–∑–ø–µ—Ä–µ—Ä–≤–Ω—ñ—Å—Ç—å –±—ñ–∑–Ω–µ—Å—É —Ç–∞ –∑–∞—Ö–∏—Å—Ç –¥–∞–Ω–∏—Ö. –ü–æ—á–Ω—ñ—Ç—å –∑ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–æ–≤–∞–Ω–∏—Ö —Ä–µ–∑–µ—Ä–≤–Ω–∏—Ö –∫–æ–ø—ñ–π —Ç–∞ –ø–æ—Å—Ç—É–ø–æ–≤–æ –≤–ø—Ä–æ–≤–∞–¥–∂—É–π—Ç–µ —Ä–æ–∑—à–∏—Ä–µ–Ω—ñ –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è.
</Callout>

**üîó –ü–æ–≤'—è–∑–∞–Ω–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è:**
- [–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –±–∞–∑–∏ –¥–∞–Ω–∏—Ö](/en/library/deployment/docker) - –ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è –±–∞–∑–∏ –¥–∞–Ω–∏—Ö
- [–ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ –±–µ–∑–ø–µ–∫–∏](/en/library/features/security) - –ù–∞–π–∫—Ä–∞—â—ñ –ø—Ä–∞–∫—Ç–∏–∫–∏ –±–µ–∑–ø–µ–∫–∏
- [–ü–æ—Å—ñ–±–Ω–∏–∫ –∑ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É](/en/library/deployment/monitoring) - –ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ —Å–∏—Å—Ç–µ–º–∏
- [–ü–ª–∞–Ω—É–≤–∞–Ω–Ω—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—ñ—Å–ª—è –∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ](/en/library/examples/real-world) - –°—Ç—Ä–∞—Ç–µ–≥—ñ—ó DR