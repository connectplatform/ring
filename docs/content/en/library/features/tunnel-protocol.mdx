---
title: Tunnel Protocol
description: Ring's multi-transport real-time communication system - the analog to Firebase Realtime Database
---

# ğŸš‡ Tunnel Protocol

**Ring's Multi-Transport Real-Time Communication**

Tunnel Protocol is Ring Platform's intelligent real-time communication system - **the Ring analog to Firebase Realtime Database**. It provides unified real-time messaging across WebSocket, Server-Sent Events (SSE), Supabase Realtime, and Long-Polling transports with automatic fallback and Edge Runtime compatibility.

## ğŸ¯ Why Tunnel Protocol?

### The Problem with Firebase RTDB

Firebase Realtime Database provides excellent real-time features but creates vendor lock-in:

- âŒ **Vendor Lock-in**: Tied to Firebase infrastructure
- âŒ **Edge Runtime Incompatible**: Cannot run on Vercel Edge
- âŒ **Cost Scaling**: Pay-per-operation pricing
- âŒ **Limited Control**: Cannot optimize for specific use cases
- âŒ **Single Transport**: WebSocket only

### The Ring Solution: Tunnel Protocol

âœ… **Transport Abstraction**: Unified API across 5+ transports  
âœ… **Edge Runtime Compatible**: SSE support for Vercel Edge  
âœ… **Zero Vendor Lock-in**: Use any backend (PostgreSQL, Supabase, Firebase)  
âœ… **Intelligent Fallback**: Automatic cascade on transport failures  
âœ… **Cost Optimized**: Self-hosted options, pay only for infrastructure  
âœ… **Anonymous Support**: Real-time features for unauthenticated users

---

## ğŸ—ï¸ Architecture Overview

<Callout type="success" title="Ring Analog to Firebase RTDB">
Tunnel Protocol is Ring's equivalent to Firebase Realtime Database, providing the same real-time capabilities with multi-transport flexibility and zero vendor lock-in.
</Callout>

### Unified Transport API

```typescript
// Single API works across ALL transports
import { publishToTunnel, subscribeToTunnel } from '@/lib/tunnel/publisher'

// Publish message (works on any transport)
await publishToTunnel(channel, eventType, data)

// Subscribe to updates (works on any transport)
const unsubscribe = subscribeToTunnel(channel, (message) => {
  console.log('Received:', message)
})
```

### Supported Transports

| Transport | Latency | Throughput | Use Case |
|-----------|---------|------------|----------|
| **WebSocket** | `<50ms` | 10K msg/s | Self-hosted, K8s clusters |
| **SSE** | `<100ms` | 1K msg/s | Vercel Edge Runtime |
| **Supabase Realtime** | `<50ms` | 5K msg/s | Supabase deployments |
| **Firebase Realtime** | `<200ms` | 1K msg/s | Firebase-full mode |
| **Long-Polling** | 500ms-2s | 100 msg/s | Ultimate fallback |

---

## ğŸš€ Quick Start

### Publishing Real-Time Updates

Replace Firebase RTDB calls with Tunnel:

**Before (Firebase RTDB):**
```typescript
import { getAdminRtdb } from '@/lib/firebase-admin.server'

const rtdb = getAdminRtdb()
await rtdb.ref(`messages/${messageId}`).set(messageData)
```

**After (Tunnel Protocol):**
```typescript
import { publishToTunnel } from '@/lib/tunnel/publisher'

await publishToTunnel(`conversation:${conversationId}`, 'message:new', messageData)
```

### Subscribing to Updates

**Before (Firebase RTDB):**
```typescript
const ref = rtdb.ref(`messages/${messageId}`)
ref.on('value', (snapshot) => {
  const data = snapshot.val()
  handleUpdate(data)
})
```

**After (Tunnel Protocol):**
```typescript
import { subscribeToTunnel } from '@/lib/tunnel/client'

const unsubscribe = subscribeToTunnel(`conversation:${conversationId}`, (message) => {
  if (message.type === 'message:new') {
    handleUpdate(message.payload)
  }
})

// Cleanup
unsubscribe()
```

---

## ğŸ’¡ Real-World Examples

### Example 1: Chat Messages

**Server-side (publish):**
```typescript
'use server'

import { initializeDatabase, getDatabaseService } from '@/lib/database/DatabaseService'
import { publishToTunnel } from '@/lib/tunnel/publisher'
import { revalidatePath } from 'next/cache'

export async function sendMessage(conversationId: string, content: string) {
  await initializeDatabase()
  const db = getDatabaseService()
  
  // Save to database (persistence)
  const result = await db.create('messages', {
    conversationId,
    content,
    timestamp: new Date()
  })
  
  if (!result.success) throw result.error
  
  // Publish real-time update (Tunnel replaces Firebase RTDB)
  await publishToTunnel(`conversation:${conversationId}`, 'message:new', {
    id: result.data.id,
    content,
    timestamp: Date.now()
  })
  
  // Revalidate (React 19 pattern)
  revalidatePath(`/[locale]/chat/${conversationId}`)
  
  return result.data
}
```

**Client-side (subscribe):**
```typescript
'use client'

import { useEffect, useState } from 'react'
import { subscribeToTunnel } from '@/lib/tunnel/client'

export function ChatMessages({ conversationId }) {
  const [messages, setMessages] = useState([])
  
  useEffect(() => {
    // Subscribe to real-time updates
    const unsubscribe = subscribeToTunnel(
      `conversation:${conversationId}`,
      (message) => {
        if (message.type === 'message:new') {
          setMessages(prev => [...prev, message.payload])
        }
      }
    )
    
    return () => unsubscribe()
  }, [conversationId])
  
  return <div>{messages.map(msg => <Message key={msg.id} {...msg} />)}</div>
}
```

### Example 2: Typing Indicators

**Publish typing status:**
```typescript
await publishToTunnel(`conversation:${conversationId}`, 'typing:start', {
  userId,
  userName,
  timestamp: Date.now()
})
```

**Subscribe to typing:**
```typescript
subscribeToTunnel(`conversation:${conversationId}`, (message) => {
  if (message.type === 'typing:start') {
    showTypingIndicator(message.payload.userName)
  }
})
```

### Example 3: Like/Unlike Updates

**Publish like update:**
```typescript
await publishToTunnel(`entity:${entityId}`, 'like:toggled', {
  likeCount: newCount,
  liked: true,
  userId
})
```

---

## ğŸ›ï¸ Transport Selection

Tunnel automatically selects optimal transport based on deployment:

### Kubernetes + PostgreSQL
```typescript
// Detected: postgres.*.svc.cluster.local
// Selected: WebSocket (wss://)
// Fallback: Long-Polling
```

### Vercel Edge Runtime
```typescript
// Detected: VERCEL=1
// Selected: SSE (Edge compatible)
// Fallback: Long-Polling
```

### Supabase Deployment
```typescript
// Detected: SUPABASE_URL configured
// Selected: Supabase Realtime
// Fallback: SSE â†’ Long-Polling
```

### Firebase Mode
```typescript
// Detected: DB_BACKEND_MODE=firebase-full
// Selected: Firebase Realtime
// Fallback: SSE â†’ Long-Polling
```

---

## ğŸ”§ Configuration

### Environment Variables

```bash
# Transport selection (optional - auto-detected)
NEXT_PUBLIC_TUNNEL_TRANSPORT=websocket # or sse, supabase, firebase

# WebSocket configuration
TUNNEL_WEBSOCKET_URL=wss://your-domain.com/api/tunnel/ws

# SSE configuration (Edge Runtime)
TUNNEL_SSE_URL=https://your-domain.com/api/tunnel/sse

# Fallback settings
TUNNEL_ENABLE_FALLBACK=true
TUNNEL_FALLBACK_TIMEOUT=5000 # 5 seconds
```

### Backend Mode Integration

Tunnel respects your database backend mode:

```typescript
// lib/database/backend-mode-config.ts
export const BACKEND_MODES = {
  'k8s-postgres-fcm': {
    tunnel: 'websocket' // Primary transport
  },
  'firebase-full': {
    tunnel: 'firebase' // Use Firebase Realtime
  },
  'supabase-fcm': {
    tunnel: 'supabase' // Use Supabase Realtime
  }
}
```

---

## ğŸ“Š Performance Characteristics

### Latency Comparison

```typescript
WebSocket:          <50ms   // Best for self-hosted
SSE:                <100ms  // Best for Edge Runtime
Supabase Realtime:  <50ms   // Best for Supabase deployments
Firebase Realtime:  <200ms  // When using Firebase mode
Long-Polling:       500ms-2s // Universal fallback
```

### Throughput Comparison

```typescript
WebSocket:          10,000 messages/second
SSE:                1,000 messages/second
Supabase Realtime:  5,000 messages/second
Firebase Realtime:  1,000 messages/second
Long-Polling:       100 messages/second
```

---

## ğŸ›¡ï¸ Security Features

### Encrypted Channels

All transports support encryption:

```typescript
await publishToTunnel(`secure:${userId}`, 'sensitive:data', {
  encrypted: true,
  data: encryptedPayload
})
```

### Rate Limiting

Built-in protection against abuse:

```typescript
// Automatic rate limiting per user/IP
Max 100 messages/minute per user
Max 1000 messages/minute per IP
```

### DDoS Protection

Transport-level protection:
- Connection limits per IP
- Message size limits
- Automatic ban for abusive patterns

---

## ğŸ¯ Migration Guide

### From Firebase RTDB

| Firebase RTDB | Tunnel Protocol |
|---------------|-----------------|
| `rtdb.ref(path).set(data)` | `publishToTunnel(channel, type, data)` |
| `rtdb.ref(path).on('value', cb)` | `subscribeToTunnel(channel, cb)` |
| `rtdb.ref(path).off()` | `unsubscribe()` |
| `rtdb.ref(path).onDisconnect()` | Handled by transport layer |

### Code Example

**Before:**
```typescript
const rtdb = getAdminRtdb()
await rtdb.ref(`typing/${conversationId}/${userId}`).set(typingData)
await rtdb.ref(`typing/${conversationId}/${userId}`).onDisconnect().remove()
```

**After:**
```typescript
await publishToTunnel(`conversation:${conversationId}`, 'typing:start', {
  userId,
  userName,
  timestamp: Date.now()
})
// Disconnect handling automatic in Tunnel transport layer
```

---

## ğŸ”¥ Advanced Features

### Message Types

Tunnel supports typed messages:

```typescript
type TunnelMessageType = 
  | 'DATA'          // Generic data
  | 'NOTIFICATION'  // Push notifications
  | 'MESSAGE'       // Chat messages
  | 'PRESENCE'      // User presence/typing
  | 'HEARTBEAT'     // Keep-alive
  | 'ACK'           // Acknowledgments
  | 'ERROR'         // Error messages
  | 'AUTH'          // Authentication
  | 'DB_INSERT'     // Database insert event
  | 'DB_UPDATE'     // Database update event
  | 'DB_DELETE'     // Database delete event
```

### Channel Patterns

Organize channels by feature:

```typescript
`conversation:${id}`     // Chat conversations
`entity:${id}`           // Entity updates
`opportunity:${id}`      // Opportunity updates
`user:${id}`             // User-specific channel
`typing:${conversationId}` // Typing indicators
`presence:${userId}`     // User presence
`global:announcements`   // Broadcast channel
```

---

## ğŸ–ï¸ Best Practices Summary

<Callout type="success" title="Tunnel Protocol Best Practices">
1. **Use Tunnel for real-time**, DatabaseService for persistence
2. **Channel naming**: Use `feature:id` pattern
3. **Message types**: Use semantic types (message:new, typing:start, etc.)
4. **Error handling**: Tunnel failures should not break core functionality
5. **React 19**: Combine with revalidatePath() for cache updates
6. **Performance**: Tunnel is async, don't await unless critical
7. **Cleanup**: Always unsubscribe in useEffect cleanup
</Callout>

---

**Built by Legion Commander for Emperor Ray**  
**Ring analog to Firebase RTDB - Zero vendor lock-in - Maximum flexibility**  
**ğŸ”¥âš”ï¸ğŸ‘‘**

