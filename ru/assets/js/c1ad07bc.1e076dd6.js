"use strict";(self.webpackChunkring_docs=self.webpackChunkring_docs||[]).push([[7453],{52635:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"libraries/firebase-service","title":"Firebase Service Library","description":"The Firebase Service Library provides comprehensive integration with Firebase services for the Ring platform, including authentication, Firestore database operations, file storage, and cloud functions.","source":"@site/docs/libraries/firebase-service.md","sourceDirName":"libraries","slug":"/libraries/firebase-service","permalink":"/ring/ru/docs/libraries/firebase-service","draft":false,"unlisted":false,"editUrl":"https://github.com/connectplatform/ring/ring-docs/tree/main/docs/libraries/firebase-service.md","tags":[],"version":"current","lastUpdatedAt":1750255417000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"\ud83d\ude80 React 19 Notification System Improvements","permalink":"/ring/ru/docs/features/notifications/react19-improvements"},"next":{"title":"Firebase Service Documentation","permalink":"/ring/ru/docs/libraries/firebase-fcm-service"}}');var t=r(74848),a=r(28453);r(4865),r(19365);const o={sidebar_position:1},s="Firebase Service Library",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Client-Side Firebase (<code>lib/firebase-service.ts</code>)",id:"client-side-firebase-libfirebase-servicets",level:3},{value:"Server-Side Firebase (<code>lib/firebase-admin.server.ts</code>)",id:"server-side-firebase-libfirebase-adminserverts",level:3},{value:"Core Operations",id:"core-operations",level:2},{value:"Document Operations",id:"document-operations",level:3},{value:"Create Document",id:"create-document",level:4},{value:"Read Document",id:"read-document",level:4},{value:"Update Document",id:"update-document",level:4},{value:"Delete Document",id:"delete-document",level:4},{value:"Query Operations",id:"query-operations",level:3},{value:"Basic Query",id:"basic-query",level:4},{value:"Paginated Query",id:"paginated-query",level:4},{value:"Real-time Subscriptions",id:"real-time-subscriptions",level:3},{value:"Document Subscription",id:"document-subscription",level:4},{value:"Collection Subscription",id:"collection-subscription",level:4},{value:"File Upload Service",id:"file-upload-service",level:2},{value:"Client-Side Upload",id:"client-side-upload",level:3},{value:"Server-Side Upload",id:"server-side-upload",level:3},{value:"Authentication Integration",id:"authentication-integration",level:2},{value:"NextAuth.js Integration",id:"nextauthjs-integration",level:3},{value:"Security Rules",id:"security-rules",level:2},{value:"Firestore Security Rules",id:"firestore-security-rules",level:3},{value:"Storage Security Rules",id:"storage-security-rules",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Firebase Error Handler",id:"firebase-error-handler",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Caching Strategy",id:"caching-strategy",level:3},{value:"Batch Operations",id:"batch-operations",level:3},{value:"Monitoring &amp; Analytics",id:"monitoring--analytics",level:2},{value:"Performance Monitoring",id:"performance-monitoring",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"firebase-service-library",children:"Firebase Service Library"})}),"\n",(0,t.jsx)(n.p,{children:"The Firebase Service Library provides comprehensive integration with Firebase services for the Ring platform, including authentication, Firestore database operations, file storage, and cloud functions."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"The Firebase library enables:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Authentication"})," - Multi-provider authentication with NextAuth.js integration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Firestore Database"})," - Real-time document database operations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cloud Storage"})," - File upload and management"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Server-Side Operations"})," - Firebase Admin SDK integration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Real-time Subscriptions"})," - Live data updates"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Security Rules"})," - Role-based access control"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,t.jsxs)(n.h3,{id:"client-side-firebase-libfirebase-servicets",children:["Client-Side Firebase (",(0,t.jsx)(n.code,{children:"lib/firebase-service.ts"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"The client-side Firebase service handles browser operations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { initializeApp } from 'firebase/app'\nimport { getFirestore } from 'firebase/firestore'\nimport { getStorage } from 'firebase/storage'\nimport { getAuth } from 'firebase/auth'\n\n// Firebase configuration\nconst firebaseConfig = {\n  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\n  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,\n  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\n  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\n  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,\n  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID\n}\n\n// Initialize Firebase\nconst app = initializeApp(firebaseConfig)\n\n// Export services\nexport const db = getFirestore(app)\nexport const storage = getStorage(app)\nexport const auth = getAuth(app)\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"server-side-firebase-libfirebase-adminserverts",children:["Server-Side Firebase (",(0,t.jsx)(n.code,{children:"lib/firebase-admin.server.ts"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"The server-side Firebase service handles secure operations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { initializeApp, getApps, cert } from 'firebase-admin/app'\nimport { getFirestore } from 'firebase-admin/firestore'\nimport { getStorage } from 'firebase-admin/storage'\nimport { getAuth } from 'firebase-admin/auth'\n\n// Initialize Firebase Admin\nconst firebaseAdminConfig = {\n  credential: cert({\n    projectId: process.env.FIREBASE_PROJECT_ID,\n    clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n    privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\\\n/g, '\\n')\n  }),\n  projectId: process.env.FIREBASE_PROJECT_ID,\n  storageBucket: process.env.FIREBASE_STORAGE_BUCKET\n}\n\n// Singleton pattern for admin app\nexport const getAdminApp = () => {\n  if (getApps().length === 0) {\n    return initializeApp(firebaseAdminConfig)\n  }\n  return getApps()[0]\n}\n\n// Export admin services\nexport const getAdminDb = () => getFirestore(getAdminApp())\nexport const getAdminStorage = () => getStorage(getAdminApp())\nexport const getAdminAuth = () => getAuth(getAdminApp())\n"})}),"\n",(0,t.jsx)(n.h2,{id:"core-operations",children:"Core Operations"}),"\n",(0,t.jsx)(n.h3,{id:"document-operations",children:"Document Operations"}),"\n",(0,t.jsx)(n.h4,{id:"create-document",children:"Create Document"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { collection, addDoc, serverTimestamp } from 'firebase/firestore'\nimport { db } from '@/lib/firebase-service'\n\nexport async function createDocument<T>(\n  collectionName: string, \n  data: Omit<T, 'id' | 'created_at' | 'updated_at'>\n): Promise<string> {\n  const docRef = await addDoc(collection(db, collectionName), {\n    ...data,\n    created_at: serverTimestamp(),\n    updated_at: serverTimestamp()\n  })\n  return docRef.id\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"read-document",children:"Read Document"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { doc, getDoc } from 'firebase/firestore'\nimport { db } from '@/lib/firebase-service'\n\nexport async function getDocument<T>(\n  collectionName: string, \n  docId: string\n): Promise<T | null> {\n  const docRef = doc(db, collectionName, docId)\n  const docSnap = await getDoc(docRef)\n  \n  if (docSnap.exists()) {\n    return { id: docSnap.id, ...docSnap.data() } as T\n  }\n  return null\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"update-document",children:"Update Document"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { doc, updateDoc, serverTimestamp } from 'firebase/firestore'\nimport { db } from '@/lib/firebase-service'\n\nexport async function updateDocument(\n  collectionName: string, \n  docId: string, \n  data: Partial<any>\n): Promise<void> {\n  const docRef = doc(db, collectionName, docId)\n  await updateDoc(docRef, {\n    ...data,\n    updated_at: serverTimestamp()\n  })\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"delete-document",children:"Delete Document"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { doc, deleteDoc } from 'firebase/firestore'\nimport { db } from '@/lib/firebase-service'\n\nexport async function deleteDocument(\n  collectionName: string, \n  docId: string\n): Promise<void> {\n  const docRef = doc(db, collectionName, docId)\n  await deleteDoc(docRef)\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"query-operations",children:"Query Operations"}),"\n",(0,t.jsx)(n.h4,{id:"basic-query",children:"Basic Query"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { collection, query, where, orderBy, limit, getDocs } from 'firebase/firestore'\nimport { db } from '@/lib/firebase-service'\n\nexport async function queryDocuments<T>(\n  collectionName: string,\n  filters: QueryFilter[],\n  sorting?: { field: string; direction: 'asc' | 'desc' },\n  limitCount?: number\n): Promise<T[]> {\n  let q = collection(db, collectionName)\n  \n  // Apply filters\n  filters.forEach(filter => {\n    q = query(q, where(filter.field, filter.operator, filter.value))\n  })\n  \n  // Apply sorting\n  if (sorting) {\n    q = query(q, orderBy(sorting.field, sorting.direction))\n  }\n  \n  // Apply limit\n  if (limitCount) {\n    q = query(q, limit(limitCount))\n  }\n  \n  const querySnapshot = await getDocs(q)\n  return querySnapshot.docs.map(doc => ({\n    id: doc.id,\n    ...doc.data()\n  } as T))\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"paginated-query",children:"Paginated Query"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { \n  collection, query, where, orderBy, limit, \n  startAfter, getDocs, QueryDocumentSnapshot \n} from 'firebase/firestore'\nimport { db } from '@/lib/firebase-service'\n\nexport async function queryDocumentsPaginated<T>(\n  collectionName: string,\n  pageSize: number = 10,\n  lastDoc?: QueryDocumentSnapshot,\n  filters?: QueryFilter[]\n): Promise<{ documents: T[]; lastDoc?: QueryDocumentSnapshot; hasMore: boolean }> {\n  let q = query(collection(db, collectionName))\n  \n  // Apply filters\n  if (filters) {\n    filters.forEach(filter => {\n      q = query(q, where(filter.field, filter.operator, filter.value))\n    })\n  }\n  \n  // Apply ordering and pagination\n  q = query(q, orderBy('created_at', 'desc'), limit(pageSize + 1))\n  \n  if (lastDoc) {\n    q = query(q, startAfter(lastDoc))\n  }\n  \n  const querySnapshot = await getDocs(q)\n  const docs = querySnapshot.docs\n  const hasMore = docs.length > pageSize\n  \n  if (hasMore) {\n    docs.pop() // Remove the extra document\n  }\n  \n  return {\n    documents: docs.map(doc => ({ id: doc.id, ...doc.data() } as T)),\n    lastDoc: docs[docs.length - 1],\n    hasMore\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"real-time-subscriptions",children:"Real-time Subscriptions"}),"\n",(0,t.jsx)(n.h4,{id:"document-subscription",children:"Document Subscription"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { doc, onSnapshot, Unsubscribe } from 'firebase/firestore'\nimport { db } from '@/lib/firebase-service'\n\nexport function subscribeToDocument<T>(\n  collectionName: string,\n  docId: string,\n  callback: (data: T | null) => void,\n  errorCallback?: (error: Error) => void\n): Unsubscribe {\n  const docRef = doc(db, collectionName, docId)\n  \n  return onSnapshot(\n    docRef,\n    (doc) => {\n      if (doc.exists()) {\n        callback({ id: doc.id, ...doc.data() } as T)\n      } else {\n        callback(null)\n      }\n    },\n    errorCallback\n  )\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"collection-subscription",children:"Collection Subscription"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { collection, query, onSnapshot, Unsubscribe } from 'firebase/firestore'\nimport { db } from '@/lib/firebase-service'\n\nexport function subscribeToCollection<T>(\n  collectionName: string,\n  queryConstraints: any[] = [],\n  callback: (data: T[]) => void,\n  errorCallback?: (error: Error) => void\n): Unsubscribe {\n  const q = query(collection(db, collectionName), ...queryConstraints)\n  \n  return onSnapshot(\n    q,\n    (querySnapshot) => {\n      const documents = querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      } as T))\n      callback(documents)\n    },\n    errorCallback\n  )\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"file-upload-service",children:"File Upload Service"}),"\n",(0,t.jsx)(n.h3,{id:"client-side-upload",children:"Client-Side Upload"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { ref, uploadBytes, getDownloadURL, uploadBytesResumable } from 'firebase/storage'\nimport { storage } from '@/lib/firebase-service'\n\nexport async function uploadFile(\n  file: File,\n  path: string,\n  onProgress?: (progress: number) => void\n): Promise<string> {\n  const storageRef = ref(storage, path)\n  \n  if (onProgress) {\n    // Upload with progress tracking\n    const uploadTask = uploadBytesResumable(storageRef, file)\n    \n    return new Promise((resolve, reject) => {\n      uploadTask.on(\n        'state_changed',\n        (snapshot) => {\n          const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100\n          onProgress(progress)\n        },\n        reject,\n        async () => {\n          const downloadURL = await getDownloadURL(uploadTask.snapshot.ref)\n          resolve(downloadURL)\n        }\n      )\n    })\n  } else {\n    // Simple upload\n    await uploadBytes(storageRef, file)\n    return getDownloadURL(storageRef)\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"server-side-upload",children:"Server-Side Upload"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { getAdminStorage } from '@/lib/firebase-admin.server'\n\nexport async function uploadFileServer(\n  fileBuffer: Buffer,\n  fileName: string,\n  contentType: string,\n  folder: string = 'uploads'\n): Promise<string> {\n  const bucket = getAdminStorage().bucket()\n  const file = bucket.file(`${folder}/${fileName}`)\n  \n  await file.save(fileBuffer, {\n    metadata: {\n      contentType,\n      metadata: {\n        uploaded_at: new Date().toISOString()\n      }\n    }\n  })\n  \n  // Make file publicly accessible\n  await file.makePublic()\n  \n  return `https://storage.googleapis.com/${bucket.name}/${file.name}`\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"authentication-integration",children:"Authentication Integration"}),"\n",(0,t.jsx)(n.h3,{id:"nextauthjs-integration",children:"NextAuth.js Integration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { getAdminAuth } from '@/lib/firebase-admin.server'\nimport { NextAuthOptions } from 'next-auth'\n\nexport async function verifyFirebaseToken(token: string) {\n  try {\n    const auth = getAdminAuth()\n    const decodedToken = await auth.verifyIdToken(token)\n    return decodedToken\n  } catch (error) {\n    console.error('Firebase token verification failed:', error)\n    throw new Error('Invalid token')\n  }\n}\n\nexport async function createFirebaseUser(userData: {\n  email: string\n  displayName?: string\n  photoURL?: string\n}) {\n  try {\n    const auth = getAdminAuth()\n    const userRecord = await auth.createUser(userData)\n    return userRecord\n  } catch (error) {\n    console.error('Firebase user creation failed:', error)\n    throw error\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"security-rules",children:"Security Rules"}),"\n",(0,t.jsx)(n.h3,{id:"firestore-security-rules",children:"Firestore Security Rules"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"rules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Users can read/write their own data\n    match /users/{userId} {\n      allow read, write: if request.auth != null && request.auth.uid == userId;\n    }\n    \n    // Public entities are readable by all, writable by authenticated users\n    match /entities/{entityId} {\n      allow read: if resource.data.visibility == 'public' || request.auth != null;\n      allow write: if request.auth != null && \n        (request.auth.uid == resource.data.created_by || hasAdminRole());\n    }\n    \n    // Opportunities have role-based access\n    match /opportunities/{opportunityId} {\n      allow read: if canReadOpportunity();\n      allow write: if request.auth != null && \n        (request.auth.uid == resource.data.created_by || hasAdminRole());\n    }\n    \n    // Helper functions\n    function hasAdminRole() {\n      return request.auth.token.role == 'ADMIN';\n    }\n    \n    function canReadOpportunity() {\n      return resource.data.visibility == 'public' || \n        (request.auth != null && (\n          resource.data.visibility == 'members' || \n          request.auth.token.role in ['CONFIDENTIAL', 'ADMIN']\n        ));\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"storage-security-rules",children:"Storage Security Rules"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"rules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // Users can upload to their own folders\n    match /users/{userId}/{allPaths=**} {\n      allow read, write: if request.auth != null && request.auth.uid == userId;\n    }\n    \n    // Public uploads (logos, etc.)\n    match /public/{allPaths=**} {\n      allow read: if true;\n      allow write: if request.auth != null;\n    }\n    \n    // Entity uploads\n    match /entities/{entityId}/{allPaths=**} {\n      allow read: if true;\n      allow write: if request.auth != null && canManageEntity(entityId);\n    }\n    \n    function canManageEntity(entityId) {\n      return request.auth.token.role == 'ADMIN' ||\n        get(/databases/$(database)/documents/entities/$(entityId)).data.created_by == request.auth.uid;\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.h3,{id:"firebase-error-handler",children:"Firebase Error Handler"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { FirebaseError } from 'firebase/app'\n\nexport interface FirebaseErrorInfo {\n  code: string\n  message: string\n  userFriendlyMessage: string\n}\n\nexport function handleFirebaseError(error: FirebaseError): FirebaseErrorInfo {\n  const errorMap: Record<string, string> = {\n    'permission-denied': 'You do not have permission to perform this action',\n    'not-found': 'The requested resource was not found',\n    'already-exists': 'This resource already exists',\n    'resource-exhausted': 'Too many requests. Please try again later',\n    'unauthenticated': 'You must be signed in to perform this action',\n    'unavailable': 'Service is temporarily unavailable'\n  }\n  \n  return {\n    code: error.code,\n    message: error.message,\n    userFriendlyMessage: errorMap[error.code] || 'An unexpected error occurred'\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,t.jsx)(n.h3,{id:"caching-strategy",children:"Caching Strategy"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { enableNetwork, disableNetwork } from 'firebase/firestore'\n\n// Enable offline persistence\nexport async function enableOfflineSupport() {\n  try {\n    await enableNetwork(db)\n  } catch (error) {\n    console.error('Failed to enable offline support:', error)\n  }\n}\n\n// Disable network for testing\nexport async function goOffline() {\n  await disableNetwork(db)\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { writeBatch, doc } from 'firebase/firestore'\nimport { db } from '@/lib/firebase-service'\n\nexport async function batchWrite(operations: BatchOperation[]) {\n  const batch = writeBatch(db)\n  \n  operations.forEach(operation => {\n    const docRef = doc(db, operation.collection, operation.id)\n    \n    switch (operation.type) {\n      case 'set':\n        batch.set(docRef, operation.data)\n        break\n      case 'update':\n        batch.update(docRef, operation.data)\n        break\n      case 'delete':\n        batch.delete(docRef)\n        break\n    }\n  })\n  \n  await batch.commit()\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"monitoring--analytics",children:"Monitoring & Analytics"}),"\n",(0,t.jsx)(n.h3,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { getPerformance, trace } from 'firebase/performance'\nimport { initializeApp } from 'firebase/app'\n\nconst app = initializeApp(firebaseConfig)\nconst perf = getPerformance(app)\n\nexport function measureOperation<T>(\n  operationName: string, \n  operation: () => Promise<T>\n): Promise<T> {\n  const traceInstance = trace(perf, operationName)\n  traceInstance.start()\n  \n  return operation()\n    .then(result => {\n      traceInstance.stop()\n      return result\n    })\n    .catch(error => {\n      traceInstance.stop()\n      throw error\n    })\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"The Firebase Service Library provides a comprehensive, type-safe, and performant integration with Firebase services, enabling all the real-time and cloud functionality of the Ring platform."})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},19365:(e,n,r)=>{r(96540);r(74848)},4865:(e,n,r)=>{r(96540),r(92303);r(74848)},28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>s});var i=r(96540);const t={},a=i.createContext(t);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);